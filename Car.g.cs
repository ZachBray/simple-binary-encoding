// <auto-generated>
//     Generated SBE (Simple Binary Encoding) message codec
// </auto-generated>

#pragma warning disable 1591 // disable warning on missing comments
using System;
using System.Text;
using Org.SbeTool.Sbe.Dll;

namespace Baseline
{
    /// <summary>
    /// Description of a basic Car
    /// </summary>
    public sealed partial class Car
    {
        public const ushort BlockLength = (ushort)45;
        public const ushort TemplateId = (ushort)1;
        public const ushort SchemaId = (ushort)1;
        public const ushort SchemaVersion = (ushort)0;
        public const string SemanticType = "";
        public const string SemanticVersion = "5.2";

        private readonly Car _parentMessage;
        private DirectBuffer _buffer;
        private int _offset;
        private int _limit;
        private int _actingBlockLength;
        private int _actingVersion;

        public int Offset { get { return _offset; } }

        public Car()
        {
            _parentMessage = this;
        }

        public Car WrapForEncode(DirectBuffer buffer, int offset)
        {
#if ENABLE_ACCESS_ORDER_CHECKS
            codecState(CodecState.V0_BLOCK);
#endif
            _buffer = buffer;
            _offset = offset;
            _actingBlockLength = BlockLength;
            _actingVersion = SchemaVersion;
            Limit = offset + _actingBlockLength;
            return this;
        }

        public Car WrapForEncodeAndApplyHeader(DirectBuffer buffer, int offset, MessageHeader headerEncoder)
        {
            headerEncoder.Wrap(buffer, offset, SchemaVersion);
            headerEncoder.BlockLength = BlockLength;
            headerEncoder.TemplateId = TemplateId;
            headerEncoder.SchemaId = SchemaId;
            headerEncoder.Version = SchemaVersion;
            
            return WrapForEncode(buffer, offset + MessageHeader.Size);
        }

        private void OnWrapForDecode(int actingVersion)
        {
            switch(actingVersion)
            {
                case 0:
                    codecState(CodecState.V0_BLOCK);
                    break;
                default:
                    codecState(CodecState.V0_BLOCK);
                    break;
            }
        }

        public Car WrapForDecode(DirectBuffer buffer, int offset, int actingBlockLength, int actingVersion)
        {
#if ENABLE_ACCESS_ORDER_CHECKS
            OnWrapForDecode(actingVersion);
#endif
            _buffer = buffer;
            _offset = offset;
            _actingBlockLength = actingBlockLength;
            _actingVersion = actingVersion;
            Limit = offset + _actingBlockLength;
            return this;
        }

        public Car WrapForDecodeAndApplyHeader(DirectBuffer buffer, int offset, MessageHeader headerDecoder)
        {
            headerDecoder.Wrap(buffer, offset, SchemaVersion);
            
            return WrapForDecode(buffer, offset + MessageHeader.Size,  headerDecoder.BlockLength, headerDecoder.Version);
        }

        public int Size
        {
            get
            {
                return _limit - _offset;
            }
        }

        public int Limit
        {
            get
            {
                return _limit;
            }
            set
            {
                _buffer.CheckLimit(value);
                _limit = value;
            }
        }

        ///
        /// <summary>
        ///   <para>
        ///     The states in which a encoder/decoder/codec can live.
        ///   </para>
        ///   <para>
        ///     The state machine diagram below, encoded in the dot language, describes
        ///     the valid state transitions according to the order in which fields may be
        ///     accessed safely. Tools such as PlantUML and Graphviz can render it.
        ///   </para>
        ///   <code>
        ///     digraph G {
        ///         NOT_WRAPPED -> V0_BLOCK [label="  wrap(version=0)  "];
        ///         V0_BLOCK -> V0_BLOCK [label="  serialNumber(?)  "];
        ///         V0_BLOCK -> V0_BLOCK [label="  modelYear(?)  "];
        ///         V0_BLOCK -> V0_BLOCK [label="  available(?)  "];
        ///         V0_BLOCK -> V0_BLOCK [label="  code(?)  "];
        ///         V0_BLOCK -> V0_BLOCK [label="  someNumbers(?)  "];
        ///         V0_BLOCK -> V0_BLOCK [label="  vehicleCode(?)  "];
        ///         V0_BLOCK -> V0_BLOCK [label="  extras(?)  "];
        ///         V0_BLOCK -> V0_BLOCK [label="  discountedModel(?)  "];
        ///         V0_BLOCK -> V0_BLOCK [label="  engine(?)  "];
        ///         V0_BLOCK -> V0_FUELFIGURES_DONE [label="  fuelFiguresCount(0)  "];
        ///         V0_BLOCK -> V0_FUELFIGURES_N [label="  fuelFiguresCount(>0)  "];
        ///         V0_FUELFIGURES_N_BLOCK -> V0_FUELFIGURES_N_BLOCK [label="  fuelFigures.speed(?)  "];
        ///         V0_FUELFIGURES_1_BLOCK -> V0_FUELFIGURES_1_BLOCK [label="  fuelFigures.speed(?)  "];
        ///         V0_FUELFIGURES_N_BLOCK -> V0_FUELFIGURES_N_BLOCK [label="  fuelFigures.mpg(?)  "];
        ///         V0_FUELFIGURES_1_BLOCK -> V0_FUELFIGURES_1_BLOCK [label="  fuelFigures.mpg(?)  "];
        ///         V0_FUELFIGURES_N_BLOCK -> V0_FUELFIGURES_N_BLOCK [label="  fuelFigures.usageDescriptionLength()  "];
        ///         V0_FUELFIGURES_1_BLOCK -> V0_FUELFIGURES_1_BLOCK [label="  fuelFigures.usageDescriptionLength()  "];
        ///         V0_FUELFIGURES_N_BLOCK -> V0_FUELFIGURES_N_USAGEDESCRIPTION_DONE [label="  fuelFigures.usageDescription(?)  "];
        ///         V0_FUELFIGURES_1_BLOCK -> V0_FUELFIGURES_1_USAGEDESCRIPTION_DONE [label="  fuelFigures.usageDescription(?)  "];
        ///         V0_FUELFIGURES_N_USAGEDESCRIPTION_DONE -> V0_FUELFIGURES_N_BLOCK [label="  fuelFigures.next()\n  where count - newIndex > 1  "];
        ///         V0_FUELFIGURES_N -> V0_FUELFIGURES_N_BLOCK [label="  fuelFigures.next()\n  where count - newIndex > 1  "];
        ///         V0_FUELFIGURES_N_USAGEDESCRIPTION_DONE -> V0_FUELFIGURES_1_BLOCK [label="  fuelFigures.next()\n  where count - newIndex == 1  "];
        ///         V0_FUELFIGURES_N -> V0_FUELFIGURES_1_BLOCK [label="  fuelFigures.next()\n  where count - newIndex == 1  "];
        ///         V0_FUELFIGURES_N_USAGEDESCRIPTION_DONE -> V0_FUELFIGURES_DONE [label="  fuelFigures.resetCountToIndex()  "];
        ///         V0_FUELFIGURES_N -> V0_FUELFIGURES_DONE [label="  fuelFigures.resetCountToIndex()  "];
        ///         V0_FUELFIGURES_1_USAGEDESCRIPTION_DONE -> V0_FUELFIGURES_DONE [label="  fuelFigures.resetCountToIndex()  "];
        ///         V0_FUELFIGURES_DONE -> V0_FUELFIGURES_DONE [label="  fuelFigures.resetCountToIndex()  "];
        ///         V0_FUELFIGURES_1_USAGEDESCRIPTION_DONE -> V0_PERFORMANCEFIGURES_DONE [label="  performanceFiguresCount(0)  "];
        ///         V0_FUELFIGURES_DONE -> V0_PERFORMANCEFIGURES_DONE [label="  performanceFiguresCount(0)  "];
        ///         V0_FUELFIGURES_1_USAGEDESCRIPTION_DONE -> V0_PERFORMANCEFIGURES_N [label="  performanceFiguresCount(>0)  "];
        ///         V0_FUELFIGURES_DONE -> V0_PERFORMANCEFIGURES_N [label="  performanceFiguresCount(>0)  "];
        ///         V0_PERFORMANCEFIGURES_N_BLOCK -> V0_PERFORMANCEFIGURES_N_BLOCK [label="  performanceFigures.octaneRating(?)  "];
        ///         V0_PERFORMANCEFIGURES_1_BLOCK -> V0_PERFORMANCEFIGURES_1_BLOCK [label="  performanceFigures.octaneRating(?)  "];
        ///         V0_PERFORMANCEFIGURES_N_BLOCK -> V0_PERFORMANCEFIGURES_N_ACCELERATION_DONE [label="  performanceFigures.accelerationCount(0)  "];
        ///         V0_PERFORMANCEFIGURES_1_BLOCK -> V0_PERFORMANCEFIGURES_1_ACCELERATION_DONE [label="  performanceFigures.accelerationCount(0)  "];
        ///         V0_PERFORMANCEFIGURES_N_BLOCK -> V0_PERFORMANCEFIGURES_N_ACCELERATION_N [label="  performanceFigures.accelerationCount(>0)  "];
        ///         V0_PERFORMANCEFIGURES_1_BLOCK -> V0_PERFORMANCEFIGURES_1_ACCELERATION_N [label="  performanceFigures.accelerationCount(>0)  "];
        ///         V0_PERFORMANCEFIGURES_N_ACCELERATION_N_BLOCK -> V0_PERFORMANCEFIGURES_N_ACCELERATION_N_BLOCK [label="  performanceFigures.acceleration.mph(?)  "];
        ///         V0_PERFORMANCEFIGURES_N_ACCELERATION_1_BLOCK -> V0_PERFORMANCEFIGURES_N_ACCELERATION_1_BLOCK [label="  performanceFigures.acceleration.mph(?)  "];
        ///         V0_PERFORMANCEFIGURES_1_ACCELERATION_N_BLOCK -> V0_PERFORMANCEFIGURES_1_ACCELERATION_N_BLOCK [label="  performanceFigures.acceleration.mph(?)  "];
        ///         V0_PERFORMANCEFIGURES_1_ACCELERATION_1_BLOCK -> V0_PERFORMANCEFIGURES_1_ACCELERATION_1_BLOCK [label="  performanceFigures.acceleration.mph(?)  "];
        ///         V0_PERFORMANCEFIGURES_N_ACCELERATION_N_BLOCK -> V0_PERFORMANCEFIGURES_N_ACCELERATION_N_BLOCK [label="  performanceFigures.acceleration.seconds(?)  "];
        ///         V0_PERFORMANCEFIGURES_N_ACCELERATION_1_BLOCK -> V0_PERFORMANCEFIGURES_N_ACCELERATION_1_BLOCK [label="  performanceFigures.acceleration.seconds(?)  "];
        ///         V0_PERFORMANCEFIGURES_1_ACCELERATION_N_BLOCK -> V0_PERFORMANCEFIGURES_1_ACCELERATION_N_BLOCK [label="  performanceFigures.acceleration.seconds(?)  "];
        ///         V0_PERFORMANCEFIGURES_1_ACCELERATION_1_BLOCK -> V0_PERFORMANCEFIGURES_1_ACCELERATION_1_BLOCK [label="  performanceFigures.acceleration.seconds(?)  "];
        ///         V0_PERFORMANCEFIGURES_N_ACCELERATION_N -> V0_PERFORMANCEFIGURES_N_ACCELERATION_N_BLOCK [label="  performanceFigures.acceleration.next()\n  where count - newIndex > 1  "];
        ///         V0_PERFORMANCEFIGURES_N_ACCELERATION_N_BLOCK -> V0_PERFORMANCEFIGURES_N_ACCELERATION_N_BLOCK [label="  performanceFigures.acceleration.next()\n  where count - newIndex > 1  "];
        ///         V0_PERFORMANCEFIGURES_1_ACCELERATION_N_BLOCK -> V0_PERFORMANCEFIGURES_1_ACCELERATION_N_BLOCK [label="  performanceFigures.acceleration.next()\n  where count - newIndex > 1  "];
        ///         V0_PERFORMANCEFIGURES_1_ACCELERATION_N -> V0_PERFORMANCEFIGURES_1_ACCELERATION_N_BLOCK [label="  performanceFigures.acceleration.next()\n  where count - newIndex > 1  "];
        ///         V0_PERFORMANCEFIGURES_N_ACCELERATION_N -> V0_PERFORMANCEFIGURES_N_ACCELERATION_1_BLOCK [label="  performanceFigures.acceleration.next()\n  where count - newIndex == 1  "];
        ///         V0_PERFORMANCEFIGURES_N_ACCELERATION_N_BLOCK -> V0_PERFORMANCEFIGURES_N_ACCELERATION_1_BLOCK [label="  performanceFigures.acceleration.next()\n  where count - newIndex == 1  "];
        ///         V0_PERFORMANCEFIGURES_1_ACCELERATION_N_BLOCK -> V0_PERFORMANCEFIGURES_1_ACCELERATION_1_BLOCK [label="  performanceFigures.acceleration.next()\n  where count - newIndex == 1  "];
        ///         V0_PERFORMANCEFIGURES_1_ACCELERATION_N -> V0_PERFORMANCEFIGURES_1_ACCELERATION_1_BLOCK [label="  performanceFigures.acceleration.next()\n  where count - newIndex == 1  "];
        ///         V0_PERFORMANCEFIGURES_N_ACCELERATION_N -> V0_PERFORMANCEFIGURES_N_ACCELERATION_DONE [label="  performanceFigures.acceleration.resetCountToIndex()  "];
        ///         V0_PERFORMANCEFIGURES_N_ACCELERATION_N_BLOCK -> V0_PERFORMANCEFIGURES_N_ACCELERATION_DONE [label="  performanceFigures.acceleration.resetCountToIndex()  "];
        ///         V0_PERFORMANCEFIGURES_N_ACCELERATION_DONE -> V0_PERFORMANCEFIGURES_N_ACCELERATION_DONE [label="  performanceFigures.acceleration.resetCountToIndex()  "];
        ///         V0_PERFORMANCEFIGURES_N_ACCELERATION_1_BLOCK -> V0_PERFORMANCEFIGURES_N_ACCELERATION_DONE [label="  performanceFigures.acceleration.resetCountToIndex()  "];
        ///         V0_PERFORMANCEFIGURES_1_ACCELERATION_1_BLOCK -> V0_PERFORMANCEFIGURES_1_ACCELERATION_DONE [label="  performanceFigures.acceleration.resetCountToIndex()  "];
        ///         V0_PERFORMANCEFIGURES_1_ACCELERATION_N_BLOCK -> V0_PERFORMANCEFIGURES_1_ACCELERATION_DONE [label="  performanceFigures.acceleration.resetCountToIndex()  "];
        ///         V0_PERFORMANCEFIGURES_1_ACCELERATION_N -> V0_PERFORMANCEFIGURES_1_ACCELERATION_DONE [label="  performanceFigures.acceleration.resetCountToIndex()  "];
        ///         V0_PERFORMANCEFIGURES_1_ACCELERATION_DONE -> V0_PERFORMANCEFIGURES_1_ACCELERATION_DONE [label="  performanceFigures.acceleration.resetCountToIndex()  "];
        ///         V0_PERFORMANCEFIGURES_N -> V0_PERFORMANCEFIGURES_N_BLOCK [label="  performanceFigures.next()\n  where count - newIndex > 1  "];
        ///         V0_PERFORMANCEFIGURES_N_ACCELERATION_DONE -> V0_PERFORMANCEFIGURES_N_BLOCK [label="  performanceFigures.next()\n  where count - newIndex > 1  "];
        ///         V0_PERFORMANCEFIGURES_N_ACCELERATION_1_BLOCK -> V0_PERFORMANCEFIGURES_N_BLOCK [label="  performanceFigures.next()\n  where count - newIndex > 1  "];
        ///         V0_PERFORMANCEFIGURES_N -> V0_PERFORMANCEFIGURES_1_BLOCK [label="  performanceFigures.next()\n  where count - newIndex == 1  "];
        ///         V0_PERFORMANCEFIGURES_N_ACCELERATION_DONE -> V0_PERFORMANCEFIGURES_1_BLOCK [label="  performanceFigures.next()\n  where count - newIndex == 1  "];
        ///         V0_PERFORMANCEFIGURES_N_ACCELERATION_1_BLOCK -> V0_PERFORMANCEFIGURES_1_BLOCK [label="  performanceFigures.next()\n  where count - newIndex == 1  "];
        ///         V0_PERFORMANCEFIGURES_1_ACCELERATION_1_BLOCK -> V0_PERFORMANCEFIGURES_DONE [label="  performanceFigures.resetCountToIndex()  "];
        ///         V0_PERFORMANCEFIGURES_DONE -> V0_PERFORMANCEFIGURES_DONE [label="  performanceFigures.resetCountToIndex()  "];
        ///         V0_PERFORMANCEFIGURES_N -> V0_PERFORMANCEFIGURES_DONE [label="  performanceFigures.resetCountToIndex()  "];
        ///         V0_PERFORMANCEFIGURES_N_ACCELERATION_DONE -> V0_PERFORMANCEFIGURES_DONE [label="  performanceFigures.resetCountToIndex()  "];
        ///         V0_PERFORMANCEFIGURES_1_ACCELERATION_DONE -> V0_PERFORMANCEFIGURES_DONE [label="  performanceFigures.resetCountToIndex()  "];
        ///         V0_PERFORMANCEFIGURES_N_ACCELERATION_1_BLOCK -> V0_PERFORMANCEFIGURES_DONE [label="  performanceFigures.resetCountToIndex()  "];
        ///         V0_PERFORMANCEFIGURES_1_ACCELERATION_1_BLOCK -> V0_PERFORMANCEFIGURES_1_ACCELERATION_1_BLOCK [label="  manufacturerLength()  "];
        ///         V0_PERFORMANCEFIGURES_DONE -> V0_PERFORMANCEFIGURES_DONE [label="  manufacturerLength()  "];
        ///         V0_PERFORMANCEFIGURES_1_ACCELERATION_DONE -> V0_PERFORMANCEFIGURES_1_ACCELERATION_DONE [label="  manufacturerLength()  "];
        ///         V0_PERFORMANCEFIGURES_1_ACCELERATION_1_BLOCK -> V0_MANUFACTURER_DONE [label="  manufacturer(?)  "];
        ///         V0_PERFORMANCEFIGURES_DONE -> V0_MANUFACTURER_DONE [label="  manufacturer(?)  "];
        ///         V0_PERFORMANCEFIGURES_1_ACCELERATION_DONE -> V0_MANUFACTURER_DONE [label="  manufacturer(?)  "];
        ///         V0_MANUFACTURER_DONE -> V0_MANUFACTURER_DONE [label="  modelLength()  "];
        ///         V0_MANUFACTURER_DONE -> V0_MODEL_DONE [label="  model(?)  "];
        ///         V0_MODEL_DONE -> V0_MODEL_DONE [label="  activationCodeLength()  "];
        ///         V0_MODEL_DONE -> V0_ACTIVATIONCODE_DONE [label="  activationCode(?)  "];
        ///     }
        ///   </code>
        /// </summary>
        private enum CodecState
        {
            NOT_WRAPPED = 0,
            V0_BLOCK = 1,
            V0_FUELFIGURES_N = 2,
            V0_FUELFIGURES_N_BLOCK = 3,
            V0_FUELFIGURES_1_BLOCK = 4,
            V0_FUELFIGURES_DONE = 5,
            V0_FUELFIGURES_N_USAGEDESCRIPTION_DONE = 6,
            V0_FUELFIGURES_1_USAGEDESCRIPTION_DONE = 7,
            V0_PERFORMANCEFIGURES_N = 8,
            V0_PERFORMANCEFIGURES_N_BLOCK = 9,
            V0_PERFORMANCEFIGURES_1_BLOCK = 10,
            V0_PERFORMANCEFIGURES_DONE = 11,
            V0_PERFORMANCEFIGURES_N_ACCELERATION_N = 12,
            V0_PERFORMANCEFIGURES_N_ACCELERATION_N_BLOCK = 13,
            V0_PERFORMANCEFIGURES_N_ACCELERATION_1_BLOCK = 14,
            V0_PERFORMANCEFIGURES_N_ACCELERATION_DONE = 15,
            V0_PERFORMANCEFIGURES_1_ACCELERATION_N = 16,
            V0_PERFORMANCEFIGURES_1_ACCELERATION_N_BLOCK = 17,
            V0_PERFORMANCEFIGURES_1_ACCELERATION_1_BLOCK = 18,
            V0_PERFORMANCEFIGURES_1_ACCELERATION_DONE = 19,
            V0_MANUFACTURER_DONE = 20,
            V0_MODEL_DONE = 21,
            V0_ACTIVATIONCODE_DONE = 22,
        }


        private static readonly string[] StateNameLookup = new []
        {
            "NOT_WRAPPED",
            "V0_BLOCK",
            "V0_FUELFIGURES_N",
            "V0_FUELFIGURES_N_BLOCK",
            "V0_FUELFIGURES_1_BLOCK",
            "V0_FUELFIGURES_DONE",
            "V0_FUELFIGURES_N_USAGEDESCRIPTION_DONE",
            "V0_FUELFIGURES_1_USAGEDESCRIPTION_DONE",
            "V0_PERFORMANCEFIGURES_N",
            "V0_PERFORMANCEFIGURES_N_BLOCK",
            "V0_PERFORMANCEFIGURES_1_BLOCK",
            "V0_PERFORMANCEFIGURES_DONE",
            "V0_PERFORMANCEFIGURES_N_ACCELERATION_N",
            "V0_PERFORMANCEFIGURES_N_ACCELERATION_N_BLOCK",
            "V0_PERFORMANCEFIGURES_N_ACCELERATION_1_BLOCK",
            "V0_PERFORMANCEFIGURES_N_ACCELERATION_DONE",
            "V0_PERFORMANCEFIGURES_1_ACCELERATION_N",
            "V0_PERFORMANCEFIGURES_1_ACCELERATION_N_BLOCK",
            "V0_PERFORMANCEFIGURES_1_ACCELERATION_1_BLOCK",
            "V0_PERFORMANCEFIGURES_1_ACCELERATION_DONE",
            "V0_MANUFACTURER_DONE",
            "V0_MODEL_DONE",
            "V0_ACTIVATIONCODE_DONE",
        };

        private static readonly string[] StateTransitionsLookup = new []
        {
            "\"wrap(version=0)\"",
            "\"serialNumber(?)\", \"modelYear(?)\", \"available(?)\", \"code(?)\", \"someNumbers(?)\", \"vehicleCode(?)\", \"extras(?)\", \"discountedModel(?)\", \"engine(?)\", \"fuelFiguresCount(0)\", \"fuelFiguresCount(>0)\"",
            "\"fuelFigures.next()\", \"fuelFigures.resetCountToIndex()\"",
            "\"fuelFigures.speed(?)\", \"fuelFigures.mpg(?)\", \"fuelFigures.usageDescriptionLength()\", \"fuelFigures.usageDescription(?)\"",
            "\"fuelFigures.speed(?)\", \"fuelFigures.mpg(?)\", \"fuelFigures.usageDescriptionLength()\", \"fuelFigures.usageDescription(?)\"",
            "\"fuelFigures.resetCountToIndex()\", \"performanceFiguresCount(0)\", \"performanceFiguresCount(>0)\"",
            "\"fuelFigures.next()\", \"fuelFigures.resetCountToIndex()\"",
            "\"fuelFigures.resetCountToIndex()\", \"performanceFiguresCount(0)\", \"performanceFiguresCount(>0)\"",
            "\"performanceFigures.next()\", \"performanceFigures.resetCountToIndex()\"",
            "\"performanceFigures.octaneRating(?)\", \"performanceFigures.accelerationCount(0)\", \"performanceFigures.accelerationCount(>0)\"",
            "\"performanceFigures.octaneRating(?)\", \"performanceFigures.accelerationCount(0)\", \"performanceFigures.accelerationCount(>0)\"",
            "\"performanceFigures.resetCountToIndex()\", \"manufacturerLength()\", \"manufacturer(?)\"",
            "\"performanceFigures.acceleration.next()\", \"performanceFigures.acceleration.resetCountToIndex()\"",
            "\"performanceFigures.acceleration.mph(?)\", \"performanceFigures.acceleration.seconds(?)\", \"performanceFigures.acceleration.next()\", \"performanceFigures.acceleration.resetCountToIndex()\"",
            "\"performanceFigures.acceleration.mph(?)\", \"performanceFigures.acceleration.seconds(?)\", \"performanceFigures.acceleration.resetCountToIndex()\", \"performanceFigures.next()\", \"performanceFigures.resetCountToIndex()\"",
            "\"performanceFigures.acceleration.resetCountToIndex()\", \"performanceFigures.next()\", \"performanceFigures.resetCountToIndex()\"",
            "\"performanceFigures.acceleration.next()\", \"performanceFigures.acceleration.resetCountToIndex()\"",
            "\"performanceFigures.acceleration.mph(?)\", \"performanceFigures.acceleration.seconds(?)\", \"performanceFigures.acceleration.next()\", \"performanceFigures.acceleration.resetCountToIndex()\"",
            "\"performanceFigures.acceleration.mph(?)\", \"performanceFigures.acceleration.seconds(?)\", \"performanceFigures.acceleration.resetCountToIndex()\", \"performanceFigures.resetCountToIndex()\", \"manufacturerLength()\", \"manufacturer(?)\"",
            "\"performanceFigures.acceleration.resetCountToIndex()\", \"performanceFigures.resetCountToIndex()\", \"manufacturerLength()\", \"manufacturer(?)\"",
            "\"modelLength()\", \"model(?)\"",
            "\"activationCodeLength()\", \"activationCode(?)\"",
            "",
        };

        private static string codecStateName(CodecState state)
        {
            return StateNameLookup[(int) state];
        }

        private static string codecStateTransitions(CodecState state)
        {
            return StateTransitionsLookup[(int) state];
        }

        private CodecState _codecState = CodecState.NOT_WRAPPED;

        private CodecState codecState()
        {
            return _codecState;
        }

        private void codecState(CodecState newState)
        {
            _codecState = newState;
        }

        public void CheckEncodingIsComplete()
        {
#if ENABLE_ACCESS_ORDER_CHECKS
            switch (_codecState)
            {
                case CodecState.V0_ACTIVATIONCODE_DONE:
                    return;
                default:
                    throw new InvalidOperationException("Not fully encoded, current state: " +
                        codecStateName(_codecState) + ", allowed transitions: " +
                        codecStateTransitions(_codecState));
            }
#endif
        }


        public const int SerialNumberId = 1;
        public const int SerialNumberSinceVersion = 0;
        public const int SerialNumberDeprecated = 0;
        public bool SerialNumberInActingVersion()
        {
            return _actingVersion >= SerialNumberSinceVersion;
        }

        public const int SerialNumberOffset = 0;

        public static string SerialNumberMetaAttribute(MetaAttribute metaAttribute)
        {
            switch (metaAttribute)
            {
                case MetaAttribute.Epoch: return "";
                case MetaAttribute.TimeUnit: return "";
                case MetaAttribute.SemanticType: return "";
                case MetaAttribute.Presence: return "required";
            }

            return "";
        }

        private void OnSerialNumberAccessed()
        {
            if (codecState() == CodecState.NOT_WRAPPED)
            {
                throw new InvalidOperationException("Illegal field access order. " +
                    "Cannot access field \"serialNumber\" in state: " + codecStateName(codecState()) +
                    ". Expected one of these transitions: [" + codecStateTransitions(codecState()) +
                    "]. Please see the diagram in the docs of the inner enum #CodecState.");
            }
        }

        public const ulong SerialNumberNullValue = 0xffffffffffffffffUL;
        public const ulong SerialNumberMinValue = 0x0UL;
        public const ulong SerialNumberMaxValue = 0xfffffffffffffffeUL;

        public ulong SerialNumber
        {
            get
            {
#if ENABLE_ACCESS_ORDER_CHECKS
                OnSerialNumberAccessed();
#endif
                return _buffer.Uint64GetLittleEndian(_offset + 0);
            }
            set
            {
#if ENABLE_ACCESS_ORDER_CHECKS
                OnSerialNumberAccessed();
#endif
                _buffer.Uint64PutLittleEndian(_offset + 0, value);
            }
        }


        public const int ModelYearId = 2;
        public const int ModelYearSinceVersion = 0;
        public const int ModelYearDeprecated = 0;
        public bool ModelYearInActingVersion()
        {
            return _actingVersion >= ModelYearSinceVersion;
        }

        public const int ModelYearOffset = 8;

        public static string ModelYearMetaAttribute(MetaAttribute metaAttribute)
        {
            switch (metaAttribute)
            {
                case MetaAttribute.Epoch: return "";
                case MetaAttribute.TimeUnit: return "";
                case MetaAttribute.SemanticType: return "";
                case MetaAttribute.Presence: return "required";
            }

            return "";
        }

        private void OnModelYearAccessed()
        {
            if (codecState() == CodecState.NOT_WRAPPED)
            {
                throw new InvalidOperationException("Illegal field access order. " +
                    "Cannot access field \"modelYear\" in state: " + codecStateName(codecState()) +
                    ". Expected one of these transitions: [" + codecStateTransitions(codecState()) +
                    "]. Please see the diagram in the docs of the inner enum #CodecState.");
            }
        }

        public const ushort ModelYearNullValue = (ushort)65535;
        public const ushort ModelYearMinValue = (ushort)0;
        public const ushort ModelYearMaxValue = (ushort)65534;

        public ushort ModelYear
        {
            get
            {
#if ENABLE_ACCESS_ORDER_CHECKS
                OnModelYearAccessed();
#endif
                return _buffer.Uint16GetLittleEndian(_offset + 8);
            }
            set
            {
#if ENABLE_ACCESS_ORDER_CHECKS
                OnModelYearAccessed();
#endif
                _buffer.Uint16PutLittleEndian(_offset + 8, value);
            }
        }


        public const int AvailableId = 3;
        public const int AvailableSinceVersion = 0;
        public const int AvailableDeprecated = 0;
        public bool AvailableInActingVersion()
        {
            return _actingVersion >= AvailableSinceVersion;
        }

        public const int AvailableOffset = 10;

        public static string AvailableMetaAttribute(MetaAttribute metaAttribute)
        {
            switch (metaAttribute)
            {
                case MetaAttribute.Epoch: return "";
                case MetaAttribute.TimeUnit: return "";
                case MetaAttribute.SemanticType: return "";
                case MetaAttribute.Presence: return "required";
            }

            return "";
        }

        private void OnAvailableAccessed()
        {
            if (codecState() == CodecState.NOT_WRAPPED)
            {
                throw new InvalidOperationException("Illegal field access order. " +
                    "Cannot access field \"available\" in state: " + codecStateName(codecState()) +
                    ". Expected one of these transitions: [" + codecStateTransitions(codecState()) +
                    "]. Please see the diagram in the docs of the inner enum #CodecState.");
            }
        }

        public BooleanType Available
        {
            get
            {
#if ENABLE_ACCESS_ORDER_CHECKS
            OnAvailableAccessed();
#endif
                return (BooleanType)_buffer.Uint8Get(_offset + 10);
            }
            set
            {
#if ENABLE_ACCESS_ORDER_CHECKS
            OnAvailableAccessed();
#endif
                _buffer.Uint8Put(_offset + 10, (byte)value);
            }
        }


        public const int CodeId = 4;
        public const int CodeSinceVersion = 0;
        public const int CodeDeprecated = 0;
        public bool CodeInActingVersion()
        {
            return _actingVersion >= CodeSinceVersion;
        }

        public const int CodeOffset = 11;

        public static string CodeMetaAttribute(MetaAttribute metaAttribute)
        {
            switch (metaAttribute)
            {
                case MetaAttribute.Epoch: return "";
                case MetaAttribute.TimeUnit: return "";
                case MetaAttribute.SemanticType: return "";
                case MetaAttribute.Presence: return "required";
            }

            return "";
        }

        private void OnCodeAccessed()
        {
            if (codecState() == CodecState.NOT_WRAPPED)
            {
                throw new InvalidOperationException("Illegal field access order. " +
                    "Cannot access field \"code\" in state: " + codecStateName(codecState()) +
                    ". Expected one of these transitions: [" + codecStateTransitions(codecState()) +
                    "]. Please see the diagram in the docs of the inner enum #CodecState.");
            }
        }

        public Model Code
        {
            get
            {
#if ENABLE_ACCESS_ORDER_CHECKS
            OnCodeAccessed();
#endif
                return (Model)_buffer.CharGet(_offset + 11);
            }
            set
            {
#if ENABLE_ACCESS_ORDER_CHECKS
            OnCodeAccessed();
#endif
                _buffer.CharPut(_offset + 11, (byte)value);
            }
        }


        public const int SomeNumbersId = 5;
        public const int SomeNumbersSinceVersion = 0;
        public const int SomeNumbersDeprecated = 0;
        public bool SomeNumbersInActingVersion()
        {
            return _actingVersion >= SomeNumbersSinceVersion;
        }

        public const int SomeNumbersOffset = 12;

        public static string SomeNumbersMetaAttribute(MetaAttribute metaAttribute)
        {
            switch (metaAttribute)
            {
                case MetaAttribute.Epoch: return "";
                case MetaAttribute.TimeUnit: return "";
                case MetaAttribute.SemanticType: return "";
                case MetaAttribute.Presence: return "required";
            }

            return "";
        }

        private void OnSomeNumbersAccessed()
        {
            if (codecState() == CodecState.NOT_WRAPPED)
            {
                throw new InvalidOperationException("Illegal field access order. " +
                    "Cannot access field \"someNumbers\" in state: " + codecStateName(codecState()) +
                    ". Expected one of these transitions: [" + codecStateTransitions(codecState()) +
                    "]. Please see the diagram in the docs of the inner enum #CodecState.");
            }
        }

        public const uint SomeNumbersNullValue = 4294967295U;
        public const uint SomeNumbersMinValue = 0U;
        public const uint SomeNumbersMaxValue = 4294967294U;

        public const int SomeNumbersLength = 4;

        public uint GetSomeNumbers(int index)
        {
            if ((uint) index >= 4)
            {
                ThrowHelper.ThrowIndexOutOfRangeException(index);
            }

#if ENABLE_ACCESS_ORDER_CHECKS
            OnSomeNumbersAccessed();
#endif
            return _buffer.Uint32GetLittleEndian(_offset + 12 + (index * 4));
        }

        public void SetSomeNumbers(int index, uint value)
        {
            if ((uint) index >= 4)
            {
                ThrowHelper.ThrowIndexOutOfRangeException(index);
            }

#if ENABLE_ACCESS_ORDER_CHECKS
            OnSomeNumbersAccessed();
#endif
            _buffer.Uint32PutLittleEndian(_offset + 12 + (index * 4), value);
        }

        public ReadOnlySpan<uint> SomeNumbers
        {
            get
            {
#if ENABLE_ACCESS_ORDER_CHECKS
                OnSomeNumbersAccessed();
#endif
                return _buffer.AsReadOnlySpan<uint>(_offset + 12, SomeNumbersLength);
            }
            set
            {
#if ENABLE_ACCESS_ORDER_CHECKS
                OnSomeNumbersAccessed();
#endif
                value.CopyTo(_buffer.AsSpan<uint>(_offset + 12, SomeNumbersLength));
            }
        }

        public Span<uint> SomeNumbersAsSpan()
        {
#if ENABLE_ACCESS_ORDER_CHECKS
            OnSomeNumbersAccessed();
#endif
            return _buffer.AsSpan<uint>(_offset + 12, SomeNumbersLength);
        }

        public const int VehicleCodeId = 6;
        public const int VehicleCodeSinceVersion = 0;
        public const int VehicleCodeDeprecated = 0;
        public bool VehicleCodeInActingVersion()
        {
            return _actingVersion >= VehicleCodeSinceVersion;
        }

        public const int VehicleCodeOffset = 28;

        public static string VehicleCodeMetaAttribute(MetaAttribute metaAttribute)
        {
            switch (metaAttribute)
            {
                case MetaAttribute.Epoch: return "";
                case MetaAttribute.TimeUnit: return "";
                case MetaAttribute.SemanticType: return "";
                case MetaAttribute.Presence: return "required";
            }

            return "";
        }

        private void OnVehicleCodeAccessed()
        {
            if (codecState() == CodecState.NOT_WRAPPED)
            {
                throw new InvalidOperationException("Illegal field access order. " +
                    "Cannot access field \"vehicleCode\" in state: " + codecStateName(codecState()) +
                    ". Expected one of these transitions: [" + codecStateTransitions(codecState()) +
                    "]. Please see the diagram in the docs of the inner enum #CodecState.");
            }
        }

        public const byte VehicleCodeNullValue = (byte)0;
        public const byte VehicleCodeMinValue = (byte)32;
        public const byte VehicleCodeMaxValue = (byte)126;

        public const int VehicleCodeLength = 6;

        public byte GetVehicleCode(int index)
        {
            if ((uint) index >= 6)
            {
                ThrowHelper.ThrowIndexOutOfRangeException(index);
            }

#if ENABLE_ACCESS_ORDER_CHECKS
            OnVehicleCodeAccessed();
#endif
            return _buffer.CharGet(_offset + 28 + (index * 1));
        }

        public void SetVehicleCode(int index, byte value)
        {
            if ((uint) index >= 6)
            {
                ThrowHelper.ThrowIndexOutOfRangeException(index);
            }

#if ENABLE_ACCESS_ORDER_CHECKS
            OnVehicleCodeAccessed();
#endif
            _buffer.CharPut(_offset + 28 + (index * 1), value);
        }

        public ReadOnlySpan<byte> VehicleCode
        {
            get
            {
#if ENABLE_ACCESS_ORDER_CHECKS
                OnVehicleCodeAccessed();
#endif
                return _buffer.AsReadOnlySpan<byte>(_offset + 28, VehicleCodeLength);
            }
            set
            {
#if ENABLE_ACCESS_ORDER_CHECKS
                OnVehicleCodeAccessed();
#endif
                value.CopyTo(_buffer.AsSpan<byte>(_offset + 28, VehicleCodeLength));
            }
        }

        public Span<byte> VehicleCodeAsSpan()
        {
#if ENABLE_ACCESS_ORDER_CHECKS
            OnVehicleCodeAccessed();
#endif
            return _buffer.AsSpan<byte>(_offset + 28, VehicleCodeLength);
        }

        public const string VehicleCodeCharacterEncoding = "ASCII";
        public static Encoding VehicleCodeResolvedCharacterEncoding = Encoding.GetEncoding(VehicleCodeCharacterEncoding);


        public int GetVehicleCode(byte[] dst, int dstOffset)
        {
            const int length = 6;
#if ENABLE_ACCESS_ORDER_CHECKS
            OnVehicleCodeAccessed();
#endif
            return GetVehicleCode(new Span<byte>(dst, dstOffset, length));
        }

        public int GetVehicleCode(Span<byte> dst)
        {
            const int length = 6;
            if (dst.Length < length)
            {
                ThrowHelper.ThrowWhenSpanLengthTooSmall(dst.Length);
            }

#if ENABLE_ACCESS_ORDER_CHECKS
            OnVehicleCodeAccessed();
#endif
            _buffer.GetBytes(_offset + 28, dst);
            return length;
        }

        public void SetVehicleCode(byte[] src, int srcOffset)
        {
            SetVehicleCode(new ReadOnlySpan<byte>(src, srcOffset, src.Length - srcOffset));
        }

        public void SetVehicleCode(ReadOnlySpan<byte> src)
        {
            const int length = 6;
            if (src.Length > length)
            {
                ThrowHelper.ThrowWhenSpanLengthTooLarge(src.Length);
            }

#if ENABLE_ACCESS_ORDER_CHECKS
            OnVehicleCodeAccessed();
#endif
            _buffer.SetBytes(_offset + 28, src);
        }

        public void SetVehicleCode(string value)
        {
#if ENABLE_ACCESS_ORDER_CHECKS
            OnVehicleCodeAccessed();
#endif
            _buffer.SetNullTerminatedBytesFromString(VehicleCodeResolvedCharacterEncoding, value, _offset + 28, VehicleCodeLength, VehicleCodeNullValue);
        }
        public string GetVehicleCode()
        {
#if ENABLE_ACCESS_ORDER_CHECKS
            OnVehicleCodeAccessed();
#endif
            return _buffer.GetStringFromNullTerminatedBytes(VehicleCodeResolvedCharacterEncoding, _offset + 28, VehicleCodeLength, VehicleCodeNullValue);
        }

        public const int ExtrasId = 7;
        public const int ExtrasSinceVersion = 0;
        public const int ExtrasDeprecated = 0;
        public bool ExtrasInActingVersion()
        {
            return _actingVersion >= ExtrasSinceVersion;
        }

        public const int ExtrasOffset = 34;

        public static string ExtrasMetaAttribute(MetaAttribute metaAttribute)
        {
            switch (metaAttribute)
            {
                case MetaAttribute.Epoch: return "";
                case MetaAttribute.TimeUnit: return "";
                case MetaAttribute.SemanticType: return "";
                case MetaAttribute.Presence: return "required";
            }

            return "";
        }

        private void OnExtrasAccessed()
        {
            if (codecState() == CodecState.NOT_WRAPPED)
            {
                throw new InvalidOperationException("Illegal field access order. " +
                    "Cannot access field \"extras\" in state: " + codecStateName(codecState()) +
                    ". Expected one of these transitions: [" + codecStateTransitions(codecState()) +
                    "]. Please see the diagram in the docs of the inner enum #CodecState.");
            }
        }

        public OptionalExtras Extras
        {
            get
            {
#if ENABLE_ACCESS_ORDER_CHECKS
            OnExtrasAccessed();
#endif
                return (OptionalExtras)_buffer.Uint8Get(_offset + 34);
            }
            set
            {
#if ENABLE_ACCESS_ORDER_CHECKS
            OnExtrasAccessed();
#endif
                _buffer.Uint8Put(_offset + 34, (byte)value);
            }
        }

        public const int DiscountedModelId = 8;
        public const int DiscountedModelSinceVersion = 0;
        public const int DiscountedModelDeprecated = 0;
        public bool DiscountedModelInActingVersion()
        {
            return _actingVersion >= DiscountedModelSinceVersion;
        }

        public const int DiscountedModelOffset = 35;

        public static string DiscountedModelMetaAttribute(MetaAttribute metaAttribute)
        {
            switch (metaAttribute)
            {
                case MetaAttribute.Epoch: return "";
                case MetaAttribute.TimeUnit: return "";
                case MetaAttribute.SemanticType: return "";
                case MetaAttribute.Presence: return "constant";
            }

            return "";
        }

        private void OnDiscountedModelAccessed()
        {
            if (codecState() == CodecState.NOT_WRAPPED)
            {
                throw new InvalidOperationException("Illegal field access order. " +
                    "Cannot access field \"discountedModel\" in state: " + codecStateName(codecState()) +
                    ". Expected one of these transitions: [" + codecStateTransitions(codecState()) +
                    "]. Please see the diagram in the docs of the inner enum #CodecState.");
            }
        }

        public Model DiscountedModel
        {
            get
            {
                return Model.C;
            }
        }


        public const int EngineId = 9;
        public const int EngineSinceVersion = 0;
        public const int EngineDeprecated = 0;
        public bool EngineInActingVersion()
        {
            return _actingVersion >= EngineSinceVersion;
        }

        public const int EngineOffset = 35;

        public static string EngineMetaAttribute(MetaAttribute metaAttribute)
        {
            switch (metaAttribute)
            {
                case MetaAttribute.Epoch: return "";
                case MetaAttribute.TimeUnit: return "";
                case MetaAttribute.SemanticType: return "";
                case MetaAttribute.Presence: return "required";
            }

            return "";
        }

        private void OnEngineAccessed()
        {
            if (codecState() == CodecState.NOT_WRAPPED)
            {
                throw new InvalidOperationException("Illegal field access order. " +
                    "Cannot access field \"engine\" in state: " + codecStateName(codecState()) +
                    ". Expected one of these transitions: [" + codecStateTransitions(codecState()) +
                    "]. Please see the diagram in the docs of the inner enum #CodecState.");
            }
        }

        private readonly Engine _engine = new Engine();

        public Engine Engine
        {
            get
            {
#if ENABLE_ACCESS_ORDER_CHECKS
                OnEngineAccessed();
#endif
                _engine.Wrap(_buffer, _offset + 35, _actingVersion);
                return _engine;
            }
        }

        private readonly FuelFiguresGroup _fuelFigures = new FuelFiguresGroup();

        public const long FuelFiguresId = 10;

        private void OnFuelFiguresAccessed(int remaining, string action)
        {
            if (remaining == 0)
            {
                switch (codecState())
                {
                    case CodecState.V0_BLOCK:
                        codecState(CodecState.V0_FUELFIGURES_DONE);
                        break;
                    default:
                        throw new InvalidOperationException("Illegal field access order. " +
                            "Cannot " + action + " count of repeating group \"fuelFigures\" in state: " + codecStateName(codecState()) +
                            ". Expected one of these transitions: [" + codecStateTransitions(codecState()) +
                            "]. Please see the diagram in the docs of the inner enum #CodecState.");
                }
            }
            else
            {
                switch (codecState())
                {
                    case CodecState.V0_BLOCK:
                        codecState(CodecState.V0_FUELFIGURES_N);
                        break;
                    default:
                        throw new InvalidOperationException("Illegal field access order. " +
                            "Cannot " + action + " count of repeating group \"fuelFigures\" in state: " + codecStateName(codecState()) +
                            ". Expected one of these transitions: [" + codecStateTransitions(codecState()) +
                            "]. Please see the diagram in the docs of the inner enum #CodecState.");
                }
            }
        }
        public const int FuelFiguresSinceVersion = 0;
        public const int FuelFiguresDeprecated = 0;
        public bool FuelFiguresInActingVersion()
        {
            return _actingVersion >= FuelFiguresSinceVersion;
        }

        public FuelFiguresGroup FuelFigures
        {
            get
            {
                _fuelFigures.WrapForDecode(_parentMessage, _buffer, _actingVersion);
#if ENABLE_ACCESS_ORDER_CHECKS
                OnFuelFiguresAccessed(_fuelFigures.Count, "decode");
#endif
                return _fuelFigures;
            }
        }

        public FuelFiguresGroup FuelFiguresCount(int count)
        {
#if ENABLE_ACCESS_ORDER_CHECKS
            OnFuelFiguresAccessed(count, "encode");
#endif
            _fuelFigures.WrapForEncode(_parentMessage, _buffer, count);
            return _fuelFigures;
        }

        public sealed partial class FuelFiguresGroup
        {
            private readonly GroupSizeEncoding _dimensions = new GroupSizeEncoding();
            private Car _parentMessage;
            private DirectBuffer _buffer;
            private int _blockLength;
            private int _actingVersion;
            private int _count;
            private int _index;
            private int _offset;

            internal void NotPresent()
            {
                _count = 0;
                _index = 0;
                _buffer = null;
                _offset = 0;
            }

            public void WrapForDecode(Car parentMessage, DirectBuffer buffer, int actingVersion)
            {
                _parentMessage = parentMessage;
                _buffer = buffer;
                _dimensions.Wrap(buffer, parentMessage.Limit, actingVersion);
                _parentMessage.Limit = parentMessage.Limit + SbeHeaderSize;
                _blockLength = _dimensions.BlockLength;
                _count = (int) _dimensions.NumInGroup;
                _actingVersion = actingVersion;
                _index = 0;
            }

            public void WrapForEncode(Car parentMessage, DirectBuffer buffer, int count)
            {
                if ((uint) count > 65534)
                {
                    ThrowHelper.ThrowCountOutOfRangeException(count);
                }

                _parentMessage = parentMessage;
                _buffer = buffer;
                _dimensions.Wrap(buffer, parentMessage.Limit, SchemaVersion);
                parentMessage.Limit = parentMessage.Limit + SbeHeaderSize;
                _dimensions.BlockLength = SbeBlockLength;
                _dimensions.NumInGroup = (ushort) count;
                _index = 0;
                _count = count;
                _blockLength = SbeBlockLength;
                _actingVersion = SchemaVersion;
            }

            public const int SbeBlockLength = 6;
            public const int SbeHeaderSize = 4;

            private CodecState codecState()
            {
                return _parentMessage.codecState();
            }

            private void codecState(CodecState newState)
            {
                _parentMessage.codecState(newState);
            }

            private void OnNextElementAccessed()
            {
                int remaining = _count - _index;
                if (remaining > 1)
                {
                    switch (codecState())
                    {
                        case CodecState.V0_FUELFIGURES_N_USAGEDESCRIPTION_DONE:
                        case CodecState.V0_FUELFIGURES_N:
                            codecState(CodecState.V0_FUELFIGURES_N_BLOCK);
                            break;
                        default:
                            throw new InvalidOperationException("Illegal field access order. " +
                                "Cannot access next element in repeating group \"fuelFigures\" in state: " + codecStateName(codecState()) +
                                ". Expected one of these transitions: [" + codecStateTransitions(codecState()) +
                                "]. Please see the diagram in the docs of the inner enum #CodecState.");
                    }
                }
                else if (remaining == 1)
                {
                    switch (codecState())
                    {
                        case CodecState.V0_FUELFIGURES_N_USAGEDESCRIPTION_DONE:
                        case CodecState.V0_FUELFIGURES_N:
                            codecState(CodecState.V0_FUELFIGURES_1_BLOCK);
                            break;
                        default:
                            throw new InvalidOperationException("Illegal field access order. " +
                                "Cannot access next element in repeating group \"fuelFigures\" in state: " + codecStateName(codecState()) +
                                ". Expected one of these transitions: [" + codecStateTransitions(codecState()) +
                                "]. Please see the diagram in the docs of the inner enum #CodecState.");
                    }
                }
            }
            private void OnResetCountToIndex()
            {
               switch (codecState())
               {
                   case CodecState.V0_FUELFIGURES_N_USAGEDESCRIPTION_DONE:
                   case CodecState.V0_FUELFIGURES_N:
                   case CodecState.V0_FUELFIGURES_1_USAGEDESCRIPTION_DONE:
                   case CodecState.V0_FUELFIGURES_DONE:
                       codecState(CodecState.V0_FUELFIGURES_DONE);
                       break;
                   default:
                       throw new InvalidOperationException("Illegal field access order. " +
                           "Cannot reset count of repeating group \"fuelFigures\" in state: " + codecStateName(codecState()) +
                           ". Expected one of these transitions: [" + codecStateTransitions(codecState()) +
                           "]. Please see the diagram in the docs of the inner enum #CodecState.");
               }
            }
            public int ActingBlockLength { get { return _blockLength; } }

            public int Count { get { return _count; } }

            public bool HasNext { get { return _index < _count; } }


            public int ResetCountToIndex()
            {
#if ENABLE_ACCESS_ORDER_CHECKS
                OnResetCountToIndex();
#endif
                _count = _index;
                _dimensions.NumInGroup = (ushort) _count;

                return _count;
            }

            public FuelFiguresGroup Next()
            {
                if (_index >= _count)
                {
                    ThrowHelper.ThrowInvalidOperationException();
                }

#if ENABLE_ACCESS_ORDER_CHECKS
                OnNextElementAccessed();
#endif
                _offset = _parentMessage.Limit;
                _parentMessage.Limit = _offset + _blockLength;
                ++_index;

                return this;
            }

            public System.Collections.IEnumerator GetEnumerator()
            {
                while (this.HasNext)
                {
                    yield return this.Next();
                }
            }

            public const int SpeedId = 11;
            public const int SpeedSinceVersion = 0;
            public const int SpeedDeprecated = 0;
            public bool SpeedInActingVersion()
            {
                return _actingVersion >= SpeedSinceVersion;
            }

            public const int SpeedOffset = 0;

            public static string SpeedMetaAttribute(MetaAttribute metaAttribute)
            {
                switch (metaAttribute)
                {
                    case MetaAttribute.Epoch: return "";
                    case MetaAttribute.TimeUnit: return "";
                    case MetaAttribute.SemanticType: return "";
                    case MetaAttribute.Presence: return "required";
                }

                return "";
            }

            private void OnSpeedAccessed()
            {
                switch (codecState())
                {
                    case CodecState.V0_FUELFIGURES_N_BLOCK:
                        codecState(CodecState.V0_FUELFIGURES_N_BLOCK);
                        break;
                    case CodecState.V0_FUELFIGURES_1_BLOCK:
                        codecState(CodecState.V0_FUELFIGURES_1_BLOCK);
                        break;
                    default:
                        throw new InvalidOperationException("Illegal field access order. " +
                            "Cannot access field \"fuelFigures.speed\" in state: " + codecStateName(codecState()) +
                            ". Expected one of these transitions: [" + codecStateTransitions(codecState()) +
                            "]. Please see the diagram in the docs of the inner enum #CodecState.");
                }
            }

            public const ushort SpeedNullValue = (ushort)65535;
            public const ushort SpeedMinValue = (ushort)0;
            public const ushort SpeedMaxValue = (ushort)65534;

            public ushort Speed
            {
                get
                {
#if ENABLE_ACCESS_ORDER_CHECKS
                    OnSpeedAccessed();
#endif
                    return _buffer.Uint16GetLittleEndian(_offset + 0);
                }
                set
                {
#if ENABLE_ACCESS_ORDER_CHECKS
                    OnSpeedAccessed();
#endif
                    _buffer.Uint16PutLittleEndian(_offset + 0, value);
                }
            }


            public const int MpgId = 12;
            public const int MpgSinceVersion = 0;
            public const int MpgDeprecated = 0;
            public bool MpgInActingVersion()
            {
                return _actingVersion >= MpgSinceVersion;
            }

            public const int MpgOffset = 2;

            public static string MpgMetaAttribute(MetaAttribute metaAttribute)
            {
                switch (metaAttribute)
                {
                    case MetaAttribute.Epoch: return "";
                    case MetaAttribute.TimeUnit: return "";
                    case MetaAttribute.SemanticType: return "";
                    case MetaAttribute.Presence: return "required";
                }

                return "";
            }

            private void OnMpgAccessed()
            {
                switch (codecState())
                {
                    case CodecState.V0_FUELFIGURES_N_BLOCK:
                        codecState(CodecState.V0_FUELFIGURES_N_BLOCK);
                        break;
                    case CodecState.V0_FUELFIGURES_1_BLOCK:
                        codecState(CodecState.V0_FUELFIGURES_1_BLOCK);
                        break;
                    default:
                        throw new InvalidOperationException("Illegal field access order. " +
                            "Cannot access field \"fuelFigures.mpg\" in state: " + codecStateName(codecState()) +
                            ". Expected one of these transitions: [" + codecStateTransitions(codecState()) +
                            "]. Please see the diagram in the docs of the inner enum #CodecState.");
                }
            }

            public const float MpgNullValue = float.NaN;
            public const float MpgMinValue = 1.401298464324817E-45f;
            public const float MpgMaxValue = 3.4028234663852886E38f;

            public float Mpg
            {
                get
                {
#if ENABLE_ACCESS_ORDER_CHECKS
                    OnMpgAccessed();
#endif
                    return _buffer.FloatGetLittleEndian(_offset + 2);
                }
                set
                {
#if ENABLE_ACCESS_ORDER_CHECKS
                    OnMpgAccessed();
#endif
                    _buffer.FloatPutLittleEndian(_offset + 2, value);
                }
            }


            public const int UsageDescriptionId = 200;
            public const int UsageDescriptionSinceVersion = 0;
            public const int UsageDescriptionDeprecated = 0;
            public bool UsageDescriptionInActingVersion()
            {
                return _actingVersion >= UsageDescriptionSinceVersion;
            }

            public const int UsageDescriptionOffset = 6;

            public const string UsageDescriptionCharacterEncoding = "ASCII";
            public static Encoding UsageDescriptionResolvedCharacterEncoding = Encoding.GetEncoding(UsageDescriptionCharacterEncoding);


            public static string UsageDescriptionMetaAttribute(MetaAttribute metaAttribute)
            {
                switch (metaAttribute)
                {
                    case MetaAttribute.Epoch: return "";
                    case MetaAttribute.TimeUnit: return "";
                    case MetaAttribute.SemanticType: return "";
                    case MetaAttribute.Presence: return "required";
                }

                return "";
            }

            private void OnUsageDescriptionLengthAccessed()
            {
                switch (codecState())
                {
                    case CodecState.V0_FUELFIGURES_N_BLOCK:
                        codecState(CodecState.V0_FUELFIGURES_N_BLOCK);
                        break;
                    case CodecState.V0_FUELFIGURES_1_BLOCK:
                        codecState(CodecState.V0_FUELFIGURES_1_BLOCK);
                        break;
                    default:
                        throw new InvalidOperationException("Illegal field access order. " +
                            "Cannot decode length of var data \"fuelFigures.usageDescription\" in state: " + codecStateName(codecState()) +
                            ". Expected one of these transitions: [" + codecStateTransitions(codecState()) +
                            "]. Please see the diagram in the docs of the inner enum #CodecState.");
                }
            }

            private void OnUsageDescriptionAccessed()
            {
                switch (codecState())
                {
                    case CodecState.V0_FUELFIGURES_N_BLOCK:
                        codecState(CodecState.V0_FUELFIGURES_N_USAGEDESCRIPTION_DONE);
                        break;
                    case CodecState.V0_FUELFIGURES_1_BLOCK:
                        codecState(CodecState.V0_FUELFIGURES_1_USAGEDESCRIPTION_DONE);
                        break;
                    default:
                        throw new InvalidOperationException("Illegal field access order. " +
                            "Cannot access field \"fuelFigures.usageDescription\" in state: " + codecStateName(codecState()) +
                            ". Expected one of these transitions: [" + codecStateTransitions(codecState()) +
                            "]. Please see the diagram in the docs of the inner enum #CodecState.");
                }
            }

            public const int UsageDescriptionHeaderSize = 4;
            
            public int UsageDescriptionLength()
            {
#if ENABLE_ACCESS_ORDER_CHECKS
                OnUsageDescriptionLengthAccessed();
#endif
                _buffer.CheckLimit(_parentMessage.Limit + 4);
                return (int)_buffer.Uint32GetLittleEndian(_parentMessage.Limit);
            }

            public int GetUsageDescription(byte[] dst, int dstOffset, int length) =>
                GetUsageDescription(new Span<byte>(dst, dstOffset, length));

            public int GetUsageDescription(Span<byte> dst)
            {
#if ENABLE_ACCESS_ORDER_CHECKS
                OnUsageDescriptionAccessed();
#endif
                const int sizeOfLengthField = 4;
                int limit = _parentMessage.Limit;
                _buffer.CheckLimit(limit + sizeOfLengthField);
                int dataLength = (int)_buffer.Uint32GetLittleEndian(limit);
                int bytesCopied = Math.Min(dst.Length, dataLength);
                _parentMessage.Limit = limit + sizeOfLengthField + dataLength;
                _buffer.GetBytes(limit + sizeOfLengthField, dst.Slice(0, bytesCopied));

                return bytesCopied;
            }
            
            // Allocates and returns a new byte array
            public byte[] GetUsageDescriptionBytes()
            {
#if ENABLE_ACCESS_ORDER_CHECKS
                OnUsageDescriptionAccessed();
#endif
                const int sizeOfLengthField = 4;
                int limit = _parentMessage.Limit;
                _buffer.CheckLimit(limit + sizeOfLengthField);
                int dataLength = (int)_buffer.Uint32GetLittleEndian(limit);
                byte[] data = new byte[dataLength];
                _parentMessage.Limit = limit + sizeOfLengthField + dataLength;
                _buffer.GetBytes(limit + sizeOfLengthField, data);

                return data;
            }

            public int SetUsageDescription(byte[] src, int srcOffset, int length) =>
                SetUsageDescription(new ReadOnlySpan<byte>(src, srcOffset, length));

            public int SetUsageDescription(ReadOnlySpan<byte> src)
            {
#if ENABLE_ACCESS_ORDER_CHECKS
                OnUsageDescriptionAccessed();
#endif
                const int sizeOfLengthField = 4;
                int limit = _parentMessage.Limit;
                _parentMessage.Limit = limit + sizeOfLengthField + src.Length;
                _buffer.Uint32PutLittleEndian(limit, (uint)src.Length);
                _buffer.SetBytes(limit + sizeOfLengthField, src);

                return src.Length;
            }

            public string GetUsageDescription()
            {
#if ENABLE_ACCESS_ORDER_CHECKS
                OnUsageDescriptionAccessed();
#endif
                const int sizeOfLengthField = 4;
                int limit = _parentMessage.Limit;
                _buffer.CheckLimit(limit + sizeOfLengthField);
                int dataLength = (int)_buffer.Uint32GetLittleEndian(limit);
                _parentMessage.Limit = limit + sizeOfLengthField + dataLength;
                return _buffer.GetStringFromBytes(UsageDescriptionResolvedCharacterEncoding, limit + sizeOfLengthField, dataLength);
            }

            public void SetUsageDescription(string value)
            {
#if ENABLE_ACCESS_ORDER_CHECKS
                OnUsageDescriptionAccessed();
#endif
                var encoding = UsageDescriptionResolvedCharacterEncoding;
                const int sizeOfLengthField = 4;
                int limit = _parentMessage.Limit;
                int byteCount = _buffer.SetBytesFromString(encoding, value, limit + sizeOfLengthField);
                _parentMessage.Limit = limit + sizeOfLengthField + byteCount;
                _buffer.Uint32PutLittleEndian(limit, (uint)byteCount);
            }

                internal void BuildString(StringBuilder builder)
                {
                    if (_buffer == null)
                    {
                        return;
                    }

                    builder.Append('(');
                    builder.Append("Speed=");
                    builder.Append(this.Speed);
                    builder.Append('|');
                    builder.Append("Mpg=");
                    builder.Append(this.Mpg);
                    builder.Append('|');
                    builder.Append("UsageDescription=");
                    builder.Append('\'').Append(GetUsageDescription()).Append('\'');
                    builder.Append(')');

                }
        }

        private readonly PerformanceFiguresGroup _performanceFigures = new PerformanceFiguresGroup();

        public const long PerformanceFiguresId = 13;

        private void OnPerformanceFiguresAccessed(int remaining, string action)
        {
            if (remaining == 0)
            {
                switch (codecState())
                {
                    case CodecState.V0_FUELFIGURES_1_USAGEDESCRIPTION_DONE:
                    case CodecState.V0_FUELFIGURES_DONE:
                        codecState(CodecState.V0_PERFORMANCEFIGURES_DONE);
                        break;
                    default:
                        throw new InvalidOperationException("Illegal field access order. " +
                            "Cannot " + action + " count of repeating group \"performanceFigures\" in state: " + codecStateName(codecState()) +
                            ". Expected one of these transitions: [" + codecStateTransitions(codecState()) +
                            "]. Please see the diagram in the docs of the inner enum #CodecState.");
                }
            }
            else
            {
                switch (codecState())
                {
                    case CodecState.V0_FUELFIGURES_1_USAGEDESCRIPTION_DONE:
                    case CodecState.V0_FUELFIGURES_DONE:
                        codecState(CodecState.V0_PERFORMANCEFIGURES_N);
                        break;
                    default:
                        throw new InvalidOperationException("Illegal field access order. " +
                            "Cannot " + action + " count of repeating group \"performanceFigures\" in state: " + codecStateName(codecState()) +
                            ". Expected one of these transitions: [" + codecStateTransitions(codecState()) +
                            "]. Please see the diagram in the docs of the inner enum #CodecState.");
                }
            }
        }
        public const int PerformanceFiguresSinceVersion = 0;
        public const int PerformanceFiguresDeprecated = 0;
        public bool PerformanceFiguresInActingVersion()
        {
            return _actingVersion >= PerformanceFiguresSinceVersion;
        }

        public PerformanceFiguresGroup PerformanceFigures
        {
            get
            {
                _performanceFigures.WrapForDecode(_parentMessage, _buffer, _actingVersion);
#if ENABLE_ACCESS_ORDER_CHECKS
                OnPerformanceFiguresAccessed(_performanceFigures.Count, "decode");
#endif
                return _performanceFigures;
            }
        }

        public PerformanceFiguresGroup PerformanceFiguresCount(int count)
        {
#if ENABLE_ACCESS_ORDER_CHECKS
            OnPerformanceFiguresAccessed(count, "encode");
#endif
            _performanceFigures.WrapForEncode(_parentMessage, _buffer, count);
            return _performanceFigures;
        }

        public sealed partial class PerformanceFiguresGroup
        {
            private readonly GroupSizeEncoding _dimensions = new GroupSizeEncoding();
            private Car _parentMessage;
            private DirectBuffer _buffer;
            private int _blockLength;
            private int _actingVersion;
            private int _count;
            private int _index;
            private int _offset;

            internal void NotPresent()
            {
                _count = 0;
                _index = 0;
                _buffer = null;
                _offset = 0;
            }

            public void WrapForDecode(Car parentMessage, DirectBuffer buffer, int actingVersion)
            {
                _parentMessage = parentMessage;
                _buffer = buffer;
                _dimensions.Wrap(buffer, parentMessage.Limit, actingVersion);
                _parentMessage.Limit = parentMessage.Limit + SbeHeaderSize;
                _blockLength = _dimensions.BlockLength;
                _count = (int) _dimensions.NumInGroup;
                _actingVersion = actingVersion;
                _index = 0;
            }

            public void WrapForEncode(Car parentMessage, DirectBuffer buffer, int count)
            {
                if ((uint) count > 65534)
                {
                    ThrowHelper.ThrowCountOutOfRangeException(count);
                }

                _parentMessage = parentMessage;
                _buffer = buffer;
                _dimensions.Wrap(buffer, parentMessage.Limit, SchemaVersion);
                parentMessage.Limit = parentMessage.Limit + SbeHeaderSize;
                _dimensions.BlockLength = SbeBlockLength;
                _dimensions.NumInGroup = (ushort) count;
                _index = 0;
                _count = count;
                _blockLength = SbeBlockLength;
                _actingVersion = SchemaVersion;
            }

            public const int SbeBlockLength = 1;
            public const int SbeHeaderSize = 4;

            private CodecState codecState()
            {
                return _parentMessage.codecState();
            }

            private void codecState(CodecState newState)
            {
                _parentMessage.codecState(newState);
            }

            private void OnNextElementAccessed()
            {
                int remaining = _count - _index;
                if (remaining > 1)
                {
                    switch (codecState())
                    {
                        case CodecState.V0_PERFORMANCEFIGURES_N:
                        case CodecState.V0_PERFORMANCEFIGURES_N_ACCELERATION_DONE:
                        case CodecState.V0_PERFORMANCEFIGURES_N_ACCELERATION_1_BLOCK:
                            codecState(CodecState.V0_PERFORMANCEFIGURES_N_BLOCK);
                            break;
                        default:
                            throw new InvalidOperationException("Illegal field access order. " +
                                "Cannot access next element in repeating group \"performanceFigures\" in state: " + codecStateName(codecState()) +
                                ". Expected one of these transitions: [" + codecStateTransitions(codecState()) +
                                "]. Please see the diagram in the docs of the inner enum #CodecState.");
                    }
                }
                else if (remaining == 1)
                {
                    switch (codecState())
                    {
                        case CodecState.V0_PERFORMANCEFIGURES_N:
                        case CodecState.V0_PERFORMANCEFIGURES_N_ACCELERATION_DONE:
                        case CodecState.V0_PERFORMANCEFIGURES_N_ACCELERATION_1_BLOCK:
                            codecState(CodecState.V0_PERFORMANCEFIGURES_1_BLOCK);
                            break;
                        default:
                            throw new InvalidOperationException("Illegal field access order. " +
                                "Cannot access next element in repeating group \"performanceFigures\" in state: " + codecStateName(codecState()) +
                                ". Expected one of these transitions: [" + codecStateTransitions(codecState()) +
                                "]. Please see the diagram in the docs of the inner enum #CodecState.");
                    }
                }
            }
            private void OnResetCountToIndex()
            {
               switch (codecState())
               {
                   case CodecState.V0_PERFORMANCEFIGURES_1_ACCELERATION_1_BLOCK:
                   case CodecState.V0_PERFORMANCEFIGURES_DONE:
                   case CodecState.V0_PERFORMANCEFIGURES_N:
                   case CodecState.V0_PERFORMANCEFIGURES_N_ACCELERATION_DONE:
                   case CodecState.V0_PERFORMANCEFIGURES_1_ACCELERATION_DONE:
                   case CodecState.V0_PERFORMANCEFIGURES_N_ACCELERATION_1_BLOCK:
                       codecState(CodecState.V0_PERFORMANCEFIGURES_DONE);
                       break;
                   default:
                       throw new InvalidOperationException("Illegal field access order. " +
                           "Cannot reset count of repeating group \"performanceFigures\" in state: " + codecStateName(codecState()) +
                           ". Expected one of these transitions: [" + codecStateTransitions(codecState()) +
                           "]. Please see the diagram in the docs of the inner enum #CodecState.");
               }
            }
            public int ActingBlockLength { get { return _blockLength; } }

            public int Count { get { return _count; } }

            public bool HasNext { get { return _index < _count; } }


            public int ResetCountToIndex()
            {
#if ENABLE_ACCESS_ORDER_CHECKS
                OnResetCountToIndex();
#endif
                _count = _index;
                _dimensions.NumInGroup = (ushort) _count;

                return _count;
            }

            public PerformanceFiguresGroup Next()
            {
                if (_index >= _count)
                {
                    ThrowHelper.ThrowInvalidOperationException();
                }

#if ENABLE_ACCESS_ORDER_CHECKS
                OnNextElementAccessed();
#endif
                _offset = _parentMessage.Limit;
                _parentMessage.Limit = _offset + _blockLength;
                ++_index;

                return this;
            }

            public System.Collections.IEnumerator GetEnumerator()
            {
                while (this.HasNext)
                {
                    yield return this.Next();
                }
            }

            public const int OctaneRatingId = 14;
            public const int OctaneRatingSinceVersion = 0;
            public const int OctaneRatingDeprecated = 0;
            public bool OctaneRatingInActingVersion()
            {
                return _actingVersion >= OctaneRatingSinceVersion;
            }

            public const int OctaneRatingOffset = 0;

            public static string OctaneRatingMetaAttribute(MetaAttribute metaAttribute)
            {
                switch (metaAttribute)
                {
                    case MetaAttribute.Epoch: return "";
                    case MetaAttribute.TimeUnit: return "";
                    case MetaAttribute.SemanticType: return "";
                    case MetaAttribute.Presence: return "required";
                }

                return "";
            }

            private void OnOctaneRatingAccessed()
            {
                switch (codecState())
                {
                    case CodecState.V0_PERFORMANCEFIGURES_N_BLOCK:
                        codecState(CodecState.V0_PERFORMANCEFIGURES_N_BLOCK);
                        break;
                    case CodecState.V0_PERFORMANCEFIGURES_1_BLOCK:
                        codecState(CodecState.V0_PERFORMANCEFIGURES_1_BLOCK);
                        break;
                    default:
                        throw new InvalidOperationException("Illegal field access order. " +
                            "Cannot access field \"performanceFigures.octaneRating\" in state: " + codecStateName(codecState()) +
                            ". Expected one of these transitions: [" + codecStateTransitions(codecState()) +
                            "]. Please see the diagram in the docs of the inner enum #CodecState.");
                }
            }

            public const byte OctaneRatingNullValue = (byte)255;
            public const byte OctaneRatingMinValue = (byte)90;
            public const byte OctaneRatingMaxValue = (byte)110;

            public byte OctaneRating
            {
                get
                {
#if ENABLE_ACCESS_ORDER_CHECKS
                    OnOctaneRatingAccessed();
#endif
                    return _buffer.Uint8Get(_offset + 0);
                }
                set
                {
#if ENABLE_ACCESS_ORDER_CHECKS
                    OnOctaneRatingAccessed();
#endif
                    _buffer.Uint8Put(_offset + 0, value);
                }
            }


            private readonly AccelerationGroup _acceleration = new AccelerationGroup();

            public const long AccelerationId = 15;

            private void OnAccelerationAccessed(int remaining, string action)
            {
                if (remaining == 0)
                {
                    switch (codecState())
                    {
                        case CodecState.V0_PERFORMANCEFIGURES_N_BLOCK:
                            codecState(CodecState.V0_PERFORMANCEFIGURES_N_ACCELERATION_DONE);
                            break;
                        case CodecState.V0_PERFORMANCEFIGURES_1_BLOCK:
                            codecState(CodecState.V0_PERFORMANCEFIGURES_1_ACCELERATION_DONE);
                            break;
                        default:
                            throw new InvalidOperationException("Illegal field access order. " +
                                "Cannot " + action + " count of repeating group \"performanceFigures.acceleration\" in state: " + codecStateName(codecState()) +
                                ". Expected one of these transitions: [" + codecStateTransitions(codecState()) +
                                "]. Please see the diagram in the docs of the inner enum #CodecState.");
                    }
                }
                else
                {
                    switch (codecState())
                    {
                        case CodecState.V0_PERFORMANCEFIGURES_N_BLOCK:
                            codecState(CodecState.V0_PERFORMANCEFIGURES_N_ACCELERATION_N);
                            break;
                        case CodecState.V0_PERFORMANCEFIGURES_1_BLOCK:
                            codecState(CodecState.V0_PERFORMANCEFIGURES_1_ACCELERATION_N);
                            break;
                        default:
                            throw new InvalidOperationException("Illegal field access order. " +
                                "Cannot " + action + " count of repeating group \"performanceFigures.acceleration\" in state: " + codecStateName(codecState()) +
                                ". Expected one of these transitions: [" + codecStateTransitions(codecState()) +
                                "]. Please see the diagram in the docs of the inner enum #CodecState.");
                    }
                }
            }
            public const int AccelerationSinceVersion = 0;
            public const int AccelerationDeprecated = 0;
            public bool AccelerationInActingVersion()
            {
                return _actingVersion >= AccelerationSinceVersion;
            }

            public AccelerationGroup Acceleration
            {
                get
                {
                    _acceleration.WrapForDecode(_parentMessage, _buffer, _actingVersion);
#if ENABLE_ACCESS_ORDER_CHECKS
                    OnAccelerationAccessed(_acceleration.Count, "decode");
#endif
                    return _acceleration;
                }
            }

            public AccelerationGroup AccelerationCount(int count)
            {
#if ENABLE_ACCESS_ORDER_CHECKS
                OnAccelerationAccessed(count, "encode");
#endif
                _acceleration.WrapForEncode(_parentMessage, _buffer, count);
                return _acceleration;
            }

            public sealed partial class AccelerationGroup
            {
                private readonly GroupSizeEncoding _dimensions = new GroupSizeEncoding();
                private Car _parentMessage;
                private DirectBuffer _buffer;
                private int _blockLength;
                private int _actingVersion;
                private int _count;
                private int _index;
                private int _offset;

                internal void NotPresent()
                {
                    _count = 0;
                    _index = 0;
                    _buffer = null;
                    _offset = 0;
                }

                public void WrapForDecode(Car parentMessage, DirectBuffer buffer, int actingVersion)
                {
                    _parentMessage = parentMessage;
                    _buffer = buffer;
                    _dimensions.Wrap(buffer, parentMessage.Limit, actingVersion);
                    _parentMessage.Limit = parentMessage.Limit + SbeHeaderSize;
                    _blockLength = _dimensions.BlockLength;
                    _count = (int) _dimensions.NumInGroup;
                    _actingVersion = actingVersion;
                    _index = 0;
                }

                public void WrapForEncode(Car parentMessage, DirectBuffer buffer, int count)
                {
                    if ((uint) count > 65534)
                    {
                        ThrowHelper.ThrowCountOutOfRangeException(count);
                    }

                    _parentMessage = parentMessage;
                    _buffer = buffer;
                    _dimensions.Wrap(buffer, parentMessage.Limit, SchemaVersion);
                    parentMessage.Limit = parentMessage.Limit + SbeHeaderSize;
                    _dimensions.BlockLength = SbeBlockLength;
                    _dimensions.NumInGroup = (ushort) count;
                    _index = 0;
                    _count = count;
                    _blockLength = SbeBlockLength;
                    _actingVersion = SchemaVersion;
                }

                public const int SbeBlockLength = 6;
                public const int SbeHeaderSize = 4;

                private CodecState codecState()
                {
                    return _parentMessage.codecState();
                }

                private void codecState(CodecState newState)
                {
                    _parentMessage.codecState(newState);
                }

                private void OnNextElementAccessed()
                {
                    int remaining = _count - _index;
                    if (remaining > 1)
                    {
                        switch (codecState())
                        {
                            case CodecState.V0_PERFORMANCEFIGURES_N_ACCELERATION_N:
                            case CodecState.V0_PERFORMANCEFIGURES_N_ACCELERATION_N_BLOCK:
                                codecState(CodecState.V0_PERFORMANCEFIGURES_N_ACCELERATION_N_BLOCK);
                                break;
                            case CodecState.V0_PERFORMANCEFIGURES_1_ACCELERATION_N_BLOCK:
                            case CodecState.V0_PERFORMANCEFIGURES_1_ACCELERATION_N:
                                codecState(CodecState.V0_PERFORMANCEFIGURES_1_ACCELERATION_N_BLOCK);
                                break;
                            default:
                                throw new InvalidOperationException("Illegal field access order. " +
                                    "Cannot access next element in repeating group \"performanceFigures.acceleration\" in state: " + codecStateName(codecState()) +
                                    ". Expected one of these transitions: [" + codecStateTransitions(codecState()) +
                                    "]. Please see the diagram in the docs of the inner enum #CodecState.");
                        }
                    }
                    else if (remaining == 1)
                    {
                        switch (codecState())
                        {
                            case CodecState.V0_PERFORMANCEFIGURES_N_ACCELERATION_N:
                            case CodecState.V0_PERFORMANCEFIGURES_N_ACCELERATION_N_BLOCK:
                                codecState(CodecState.V0_PERFORMANCEFIGURES_N_ACCELERATION_1_BLOCK);
                                break;
                            case CodecState.V0_PERFORMANCEFIGURES_1_ACCELERATION_N_BLOCK:
                            case CodecState.V0_PERFORMANCEFIGURES_1_ACCELERATION_N:
                                codecState(CodecState.V0_PERFORMANCEFIGURES_1_ACCELERATION_1_BLOCK);
                                break;
                            default:
                                throw new InvalidOperationException("Illegal field access order. " +
                                    "Cannot access next element in repeating group \"performanceFigures.acceleration\" in state: " + codecStateName(codecState()) +
                                    ". Expected one of these transitions: [" + codecStateTransitions(codecState()) +
                                    "]. Please see the diagram in the docs of the inner enum #CodecState.");
                        }
                    }
                }
                private void OnResetCountToIndex()
                {
                   switch (codecState())
                   {
                       case CodecState.V0_PERFORMANCEFIGURES_N_ACCELERATION_N:
                       case CodecState.V0_PERFORMANCEFIGURES_N_ACCELERATION_N_BLOCK:
                       case CodecState.V0_PERFORMANCEFIGURES_N_ACCELERATION_DONE:
                       case CodecState.V0_PERFORMANCEFIGURES_N_ACCELERATION_1_BLOCK:
                           codecState(CodecState.V0_PERFORMANCEFIGURES_N_ACCELERATION_DONE);
                           break;
                       case CodecState.V0_PERFORMANCEFIGURES_1_ACCELERATION_1_BLOCK:
                       case CodecState.V0_PERFORMANCEFIGURES_1_ACCELERATION_N_BLOCK:
                       case CodecState.V0_PERFORMANCEFIGURES_1_ACCELERATION_N:
                       case CodecState.V0_PERFORMANCEFIGURES_1_ACCELERATION_DONE:
                           codecState(CodecState.V0_PERFORMANCEFIGURES_1_ACCELERATION_DONE);
                           break;
                       default:
                           throw new InvalidOperationException("Illegal field access order. " +
                               "Cannot reset count of repeating group \"performanceFigures.acceleration\" in state: " + codecStateName(codecState()) +
                               ". Expected one of these transitions: [" + codecStateTransitions(codecState()) +
                               "]. Please see the diagram in the docs of the inner enum #CodecState.");
                   }
                }
                public int ActingBlockLength { get { return _blockLength; } }

                public int Count { get { return _count; } }

                public bool HasNext { get { return _index < _count; } }


                public int ResetCountToIndex()
                {
#if ENABLE_ACCESS_ORDER_CHECKS
                    OnResetCountToIndex();
#endif
                    _count = _index;
                    _dimensions.NumInGroup = (ushort) _count;

                    return _count;
                }

                public AccelerationGroup Next()
                {
                    if (_index >= _count)
                    {
                        ThrowHelper.ThrowInvalidOperationException();
                    }

#if ENABLE_ACCESS_ORDER_CHECKS
                    OnNextElementAccessed();
#endif
                    _offset = _parentMessage.Limit;
                    _parentMessage.Limit = _offset + _blockLength;
                    ++_index;

                    return this;
                }

                public System.Collections.IEnumerator GetEnumerator()
                {
                    while (this.HasNext)
                    {
                        yield return this.Next();
                    }
                }

                public const int MphId = 16;
                public const int MphSinceVersion = 0;
                public const int MphDeprecated = 0;
                public bool MphInActingVersion()
                {
                    return _actingVersion >= MphSinceVersion;
                }

                public const int MphOffset = 0;

                public static string MphMetaAttribute(MetaAttribute metaAttribute)
                {
                    switch (metaAttribute)
                    {
                        case MetaAttribute.Epoch: return "";
                        case MetaAttribute.TimeUnit: return "";
                        case MetaAttribute.SemanticType: return "";
                        case MetaAttribute.Presence: return "required";
                    }

                    return "";
                }

                private void OnMphAccessed()
                {
                    switch (codecState())
                    {
                        case CodecState.V0_PERFORMANCEFIGURES_N_ACCELERATION_N_BLOCK:
                            codecState(CodecState.V0_PERFORMANCEFIGURES_N_ACCELERATION_N_BLOCK);
                            break;
                        case CodecState.V0_PERFORMANCEFIGURES_N_ACCELERATION_1_BLOCK:
                            codecState(CodecState.V0_PERFORMANCEFIGURES_N_ACCELERATION_1_BLOCK);
                            break;
                        case CodecState.V0_PERFORMANCEFIGURES_1_ACCELERATION_N_BLOCK:
                            codecState(CodecState.V0_PERFORMANCEFIGURES_1_ACCELERATION_N_BLOCK);
                            break;
                        case CodecState.V0_PERFORMANCEFIGURES_1_ACCELERATION_1_BLOCK:
                            codecState(CodecState.V0_PERFORMANCEFIGURES_1_ACCELERATION_1_BLOCK);
                            break;
                        default:
                            throw new InvalidOperationException("Illegal field access order. " +
                                "Cannot access field \"performanceFigures.acceleration.mph\" in state: " + codecStateName(codecState()) +
                                ". Expected one of these transitions: [" + codecStateTransitions(codecState()) +
                                "]. Please see the diagram in the docs of the inner enum #CodecState.");
                    }
                }

                public const ushort MphNullValue = (ushort)65535;
                public const ushort MphMinValue = (ushort)0;
                public const ushort MphMaxValue = (ushort)65534;

                public ushort Mph
                {
                    get
                    {
#if ENABLE_ACCESS_ORDER_CHECKS
                        OnMphAccessed();
#endif
                        return _buffer.Uint16GetLittleEndian(_offset + 0);
                    }
                    set
                    {
#if ENABLE_ACCESS_ORDER_CHECKS
                        OnMphAccessed();
#endif
                        _buffer.Uint16PutLittleEndian(_offset + 0, value);
                    }
                }


                public const int SecondsId = 17;
                public const int SecondsSinceVersion = 0;
                public const int SecondsDeprecated = 0;
                public bool SecondsInActingVersion()
                {
                    return _actingVersion >= SecondsSinceVersion;
                }

                public const int SecondsOffset = 2;

                public static string SecondsMetaAttribute(MetaAttribute metaAttribute)
                {
                    switch (metaAttribute)
                    {
                        case MetaAttribute.Epoch: return "";
                        case MetaAttribute.TimeUnit: return "";
                        case MetaAttribute.SemanticType: return "";
                        case MetaAttribute.Presence: return "required";
                    }

                    return "";
                }

                private void OnSecondsAccessed()
                {
                    switch (codecState())
                    {
                        case CodecState.V0_PERFORMANCEFIGURES_N_ACCELERATION_N_BLOCK:
                            codecState(CodecState.V0_PERFORMANCEFIGURES_N_ACCELERATION_N_BLOCK);
                            break;
                        case CodecState.V0_PERFORMANCEFIGURES_N_ACCELERATION_1_BLOCK:
                            codecState(CodecState.V0_PERFORMANCEFIGURES_N_ACCELERATION_1_BLOCK);
                            break;
                        case CodecState.V0_PERFORMANCEFIGURES_1_ACCELERATION_N_BLOCK:
                            codecState(CodecState.V0_PERFORMANCEFIGURES_1_ACCELERATION_N_BLOCK);
                            break;
                        case CodecState.V0_PERFORMANCEFIGURES_1_ACCELERATION_1_BLOCK:
                            codecState(CodecState.V0_PERFORMANCEFIGURES_1_ACCELERATION_1_BLOCK);
                            break;
                        default:
                            throw new InvalidOperationException("Illegal field access order. " +
                                "Cannot access field \"performanceFigures.acceleration.seconds\" in state: " + codecStateName(codecState()) +
                                ". Expected one of these transitions: [" + codecStateTransitions(codecState()) +
                                "]. Please see the diagram in the docs of the inner enum #CodecState.");
                    }
                }

                public const float SecondsNullValue = float.NaN;
                public const float SecondsMinValue = 1.401298464324817E-45f;
                public const float SecondsMaxValue = 3.4028234663852886E38f;

                public float Seconds
                {
                    get
                    {
#if ENABLE_ACCESS_ORDER_CHECKS
                        OnSecondsAccessed();
#endif
                        return _buffer.FloatGetLittleEndian(_offset + 2);
                    }
                    set
                    {
#if ENABLE_ACCESS_ORDER_CHECKS
                        OnSecondsAccessed();
#endif
                        _buffer.FloatPutLittleEndian(_offset + 2, value);
                    }
                }


                    internal void BuildString(StringBuilder builder)
                    {
                        if (_buffer == null)
                        {
                            return;
                        }

                        builder.Append('(');
                        builder.Append("Mph=");
                        builder.Append(this.Mph);
                        builder.Append('|');
                        builder.Append("Seconds=");
                        builder.Append(this.Seconds);
                        builder.Append(')');

                    }
            }

                internal void BuildString(StringBuilder builder)
                {
                    if (_buffer == null)
                    {
                        return;
                    }

                    builder.Append('(');
                    builder.Append("OctaneRating=");
                    builder.Append(this.OctaneRating);
                    builder.Append('|');
                    builder.Append("Acceleration=[");
                    var acceleration = this.Acceleration;
                    if (acceleration.Count > 0)
                    {
                        var first = true;
                        while (acceleration.HasNext)
                        {
                            if (!first)
                            {
                                builder.Append(',');
                            }
                            first = false;
                            acceleration.Next().BuildString(builder);
                        }
                    }
                    builder.Append("]");
                    builder.Append(')');

                }
        }

        public const int ManufacturerId = 18;
        public const int ManufacturerSinceVersion = 0;
        public const int ManufacturerDeprecated = 0;
        public bool ManufacturerInActingVersion()
        {
            return _actingVersion >= ManufacturerSinceVersion;
        }

        public const int ManufacturerOffset = -1;

        public const string ManufacturerCharacterEncoding = "UTF-8";
        public static Encoding ManufacturerResolvedCharacterEncoding = Encoding.GetEncoding(ManufacturerCharacterEncoding);


        public static string ManufacturerMetaAttribute(MetaAttribute metaAttribute)
        {
            switch (metaAttribute)
            {
                case MetaAttribute.Epoch: return "";
                case MetaAttribute.TimeUnit: return "";
                case MetaAttribute.SemanticType: return "";
                case MetaAttribute.Presence: return "required";
            }

            return "";
        }

        private void OnManufacturerLengthAccessed()
        {
            switch (codecState())
            {
                case CodecState.V0_PERFORMANCEFIGURES_1_ACCELERATION_1_BLOCK:
                    codecState(CodecState.V0_PERFORMANCEFIGURES_1_ACCELERATION_1_BLOCK);
                    break;
                case CodecState.V0_PERFORMANCEFIGURES_DONE:
                    codecState(CodecState.V0_PERFORMANCEFIGURES_DONE);
                    break;
                case CodecState.V0_PERFORMANCEFIGURES_1_ACCELERATION_DONE:
                    codecState(CodecState.V0_PERFORMANCEFIGURES_1_ACCELERATION_DONE);
                    break;
                default:
                    throw new InvalidOperationException("Illegal field access order. " +
                        "Cannot decode length of var data \"manufacturer\" in state: " + codecStateName(codecState()) +
                        ". Expected one of these transitions: [" + codecStateTransitions(codecState()) +
                        "]. Please see the diagram in the docs of the inner enum #CodecState.");
            }
        }

        private void OnManufacturerAccessed()
        {
            switch (codecState())
            {
                case CodecState.V0_PERFORMANCEFIGURES_1_ACCELERATION_1_BLOCK:
                case CodecState.V0_PERFORMANCEFIGURES_DONE:
                case CodecState.V0_PERFORMANCEFIGURES_1_ACCELERATION_DONE:
                    codecState(CodecState.V0_MANUFACTURER_DONE);
                    break;
                default:
                    throw new InvalidOperationException("Illegal field access order. " +
                        "Cannot access field \"manufacturer\" in state: " + codecStateName(codecState()) +
                        ". Expected one of these transitions: [" + codecStateTransitions(codecState()) +
                        "]. Please see the diagram in the docs of the inner enum #CodecState.");
            }
        }

        public const int ManufacturerHeaderSize = 4;
        
        public int ManufacturerLength()
        {
#if ENABLE_ACCESS_ORDER_CHECKS
            OnManufacturerLengthAccessed();
#endif
            _buffer.CheckLimit(_parentMessage.Limit + 4);
            return (int)_buffer.Uint32GetLittleEndian(_parentMessage.Limit);
        }

        public int GetManufacturer(byte[] dst, int dstOffset, int length) =>
            GetManufacturer(new Span<byte>(dst, dstOffset, length));

        public int GetManufacturer(Span<byte> dst)
        {
#if ENABLE_ACCESS_ORDER_CHECKS
            OnManufacturerAccessed();
#endif
            const int sizeOfLengthField = 4;
            int limit = _parentMessage.Limit;
            _buffer.CheckLimit(limit + sizeOfLengthField);
            int dataLength = (int)_buffer.Uint32GetLittleEndian(limit);
            int bytesCopied = Math.Min(dst.Length, dataLength);
            _parentMessage.Limit = limit + sizeOfLengthField + dataLength;
            _buffer.GetBytes(limit + sizeOfLengthField, dst.Slice(0, bytesCopied));

            return bytesCopied;
        }
        
        // Allocates and returns a new byte array
        public byte[] GetManufacturerBytes()
        {
#if ENABLE_ACCESS_ORDER_CHECKS
            OnManufacturerAccessed();
#endif
            const int sizeOfLengthField = 4;
            int limit = _parentMessage.Limit;
            _buffer.CheckLimit(limit + sizeOfLengthField);
            int dataLength = (int)_buffer.Uint32GetLittleEndian(limit);
            byte[] data = new byte[dataLength];
            _parentMessage.Limit = limit + sizeOfLengthField + dataLength;
            _buffer.GetBytes(limit + sizeOfLengthField, data);

            return data;
        }

        public int SetManufacturer(byte[] src, int srcOffset, int length) =>
            SetManufacturer(new ReadOnlySpan<byte>(src, srcOffset, length));

        public int SetManufacturer(ReadOnlySpan<byte> src)
        {
#if ENABLE_ACCESS_ORDER_CHECKS
            OnManufacturerAccessed();
#endif
            const int sizeOfLengthField = 4;
            int limit = _parentMessage.Limit;
            _parentMessage.Limit = limit + sizeOfLengthField + src.Length;
            _buffer.Uint32PutLittleEndian(limit, (uint)src.Length);
            _buffer.SetBytes(limit + sizeOfLengthField, src);

            return src.Length;
        }

        public string GetManufacturer()
        {
#if ENABLE_ACCESS_ORDER_CHECKS
            OnManufacturerAccessed();
#endif
            const int sizeOfLengthField = 4;
            int limit = _parentMessage.Limit;
            _buffer.CheckLimit(limit + sizeOfLengthField);
            int dataLength = (int)_buffer.Uint32GetLittleEndian(limit);
            _parentMessage.Limit = limit + sizeOfLengthField + dataLength;
            return _buffer.GetStringFromBytes(ManufacturerResolvedCharacterEncoding, limit + sizeOfLengthField, dataLength);
        }

        public void SetManufacturer(string value)
        {
#if ENABLE_ACCESS_ORDER_CHECKS
            OnManufacturerAccessed();
#endif
            var encoding = ManufacturerResolvedCharacterEncoding;
            const int sizeOfLengthField = 4;
            int limit = _parentMessage.Limit;
            int byteCount = _buffer.SetBytesFromString(encoding, value, limit + sizeOfLengthField);
            _parentMessage.Limit = limit + sizeOfLengthField + byteCount;
            _buffer.Uint32PutLittleEndian(limit, (uint)byteCount);
        }

        public const int ModelId = 19;
        public const int ModelSinceVersion = 0;
        public const int ModelDeprecated = 0;
        public bool ModelInActingVersion()
        {
            return _actingVersion >= ModelSinceVersion;
        }

        public const int ModelOffset = -1;

        public const string ModelCharacterEncoding = "UTF-8";
        public static Encoding ModelResolvedCharacterEncoding = Encoding.GetEncoding(ModelCharacterEncoding);


        public static string ModelMetaAttribute(MetaAttribute metaAttribute)
        {
            switch (metaAttribute)
            {
                case MetaAttribute.Epoch: return "";
                case MetaAttribute.TimeUnit: return "";
                case MetaAttribute.SemanticType: return "";
                case MetaAttribute.Presence: return "required";
            }

            return "";
        }

        private void OnModelLengthAccessed()
        {
            switch (codecState())
            {
                case CodecState.V0_MANUFACTURER_DONE:
                    codecState(CodecState.V0_MANUFACTURER_DONE);
                    break;
                default:
                    throw new InvalidOperationException("Illegal field access order. " +
                        "Cannot decode length of var data \"model\" in state: " + codecStateName(codecState()) +
                        ". Expected one of these transitions: [" + codecStateTransitions(codecState()) +
                        "]. Please see the diagram in the docs of the inner enum #CodecState.");
            }
        }

        private void OnModelAccessed()
        {
            switch (codecState())
            {
                case CodecState.V0_MANUFACTURER_DONE:
                    codecState(CodecState.V0_MODEL_DONE);
                    break;
                default:
                    throw new InvalidOperationException("Illegal field access order. " +
                        "Cannot access field \"model\" in state: " + codecStateName(codecState()) +
                        ". Expected one of these transitions: [" + codecStateTransitions(codecState()) +
                        "]. Please see the diagram in the docs of the inner enum #CodecState.");
            }
        }

        public const int ModelHeaderSize = 4;
        
        public int ModelLength()
        {
#if ENABLE_ACCESS_ORDER_CHECKS
            OnModelLengthAccessed();
#endif
            _buffer.CheckLimit(_parentMessage.Limit + 4);
            return (int)_buffer.Uint32GetLittleEndian(_parentMessage.Limit);
        }

        public int GetModel(byte[] dst, int dstOffset, int length) =>
            GetModel(new Span<byte>(dst, dstOffset, length));

        public int GetModel(Span<byte> dst)
        {
#if ENABLE_ACCESS_ORDER_CHECKS
            OnModelAccessed();
#endif
            const int sizeOfLengthField = 4;
            int limit = _parentMessage.Limit;
            _buffer.CheckLimit(limit + sizeOfLengthField);
            int dataLength = (int)_buffer.Uint32GetLittleEndian(limit);
            int bytesCopied = Math.Min(dst.Length, dataLength);
            _parentMessage.Limit = limit + sizeOfLengthField + dataLength;
            _buffer.GetBytes(limit + sizeOfLengthField, dst.Slice(0, bytesCopied));

            return bytesCopied;
        }
        
        // Allocates and returns a new byte array
        public byte[] GetModelBytes()
        {
#if ENABLE_ACCESS_ORDER_CHECKS
            OnModelAccessed();
#endif
            const int sizeOfLengthField = 4;
            int limit = _parentMessage.Limit;
            _buffer.CheckLimit(limit + sizeOfLengthField);
            int dataLength = (int)_buffer.Uint32GetLittleEndian(limit);
            byte[] data = new byte[dataLength];
            _parentMessage.Limit = limit + sizeOfLengthField + dataLength;
            _buffer.GetBytes(limit + sizeOfLengthField, data);

            return data;
        }

        public int SetModel(byte[] src, int srcOffset, int length) =>
            SetModel(new ReadOnlySpan<byte>(src, srcOffset, length));

        public int SetModel(ReadOnlySpan<byte> src)
        {
#if ENABLE_ACCESS_ORDER_CHECKS
            OnModelAccessed();
#endif
            const int sizeOfLengthField = 4;
            int limit = _parentMessage.Limit;
            _parentMessage.Limit = limit + sizeOfLengthField + src.Length;
            _buffer.Uint32PutLittleEndian(limit, (uint)src.Length);
            _buffer.SetBytes(limit + sizeOfLengthField, src);

            return src.Length;
        }

        public string GetModel()
        {
#if ENABLE_ACCESS_ORDER_CHECKS
            OnModelAccessed();
#endif
            const int sizeOfLengthField = 4;
            int limit = _parentMessage.Limit;
            _buffer.CheckLimit(limit + sizeOfLengthField);
            int dataLength = (int)_buffer.Uint32GetLittleEndian(limit);
            _parentMessage.Limit = limit + sizeOfLengthField + dataLength;
            return _buffer.GetStringFromBytes(ModelResolvedCharacterEncoding, limit + sizeOfLengthField, dataLength);
        }

        public void SetModel(string value)
        {
#if ENABLE_ACCESS_ORDER_CHECKS
            OnModelAccessed();
#endif
            var encoding = ModelResolvedCharacterEncoding;
            const int sizeOfLengthField = 4;
            int limit = _parentMessage.Limit;
            int byteCount = _buffer.SetBytesFromString(encoding, value, limit + sizeOfLengthField);
            _parentMessage.Limit = limit + sizeOfLengthField + byteCount;
            _buffer.Uint32PutLittleEndian(limit, (uint)byteCount);
        }

        public const int ActivationCodeId = 20;
        public const int ActivationCodeSinceVersion = 0;
        public const int ActivationCodeDeprecated = 0;
        public bool ActivationCodeInActingVersion()
        {
            return _actingVersion >= ActivationCodeSinceVersion;
        }

        public const int ActivationCodeOffset = -1;

        public const string ActivationCodeCharacterEncoding = "ASCII";
        public static Encoding ActivationCodeResolvedCharacterEncoding = Encoding.GetEncoding(ActivationCodeCharacterEncoding);


        public static string ActivationCodeMetaAttribute(MetaAttribute metaAttribute)
        {
            switch (metaAttribute)
            {
                case MetaAttribute.Epoch: return "";
                case MetaAttribute.TimeUnit: return "";
                case MetaAttribute.SemanticType: return "";
                case MetaAttribute.Presence: return "required";
            }

            return "";
        }

        private void OnActivationCodeLengthAccessed()
        {
            switch (codecState())
            {
                case CodecState.V0_MODEL_DONE:
                    codecState(CodecState.V0_MODEL_DONE);
                    break;
                default:
                    throw new InvalidOperationException("Illegal field access order. " +
                        "Cannot decode length of var data \"activationCode\" in state: " + codecStateName(codecState()) +
                        ". Expected one of these transitions: [" + codecStateTransitions(codecState()) +
                        "]. Please see the diagram in the docs of the inner enum #CodecState.");
            }
        }

        private void OnActivationCodeAccessed()
        {
            switch (codecState())
            {
                case CodecState.V0_MODEL_DONE:
                    codecState(CodecState.V0_ACTIVATIONCODE_DONE);
                    break;
                default:
                    throw new InvalidOperationException("Illegal field access order. " +
                        "Cannot access field \"activationCode\" in state: " + codecStateName(codecState()) +
                        ". Expected one of these transitions: [" + codecStateTransitions(codecState()) +
                        "]. Please see the diagram in the docs of the inner enum #CodecState.");
            }
        }

        public const int ActivationCodeHeaderSize = 4;
        
        public int ActivationCodeLength()
        {
#if ENABLE_ACCESS_ORDER_CHECKS
            OnActivationCodeLengthAccessed();
#endif
            _buffer.CheckLimit(_parentMessage.Limit + 4);
            return (int)_buffer.Uint32GetLittleEndian(_parentMessage.Limit);
        }

        public int GetActivationCode(byte[] dst, int dstOffset, int length) =>
            GetActivationCode(new Span<byte>(dst, dstOffset, length));

        public int GetActivationCode(Span<byte> dst)
        {
#if ENABLE_ACCESS_ORDER_CHECKS
            OnActivationCodeAccessed();
#endif
            const int sizeOfLengthField = 4;
            int limit = _parentMessage.Limit;
            _buffer.CheckLimit(limit + sizeOfLengthField);
            int dataLength = (int)_buffer.Uint32GetLittleEndian(limit);
            int bytesCopied = Math.Min(dst.Length, dataLength);
            _parentMessage.Limit = limit + sizeOfLengthField + dataLength;
            _buffer.GetBytes(limit + sizeOfLengthField, dst.Slice(0, bytesCopied));

            return bytesCopied;
        }
        
        // Allocates and returns a new byte array
        public byte[] GetActivationCodeBytes()
        {
#if ENABLE_ACCESS_ORDER_CHECKS
            OnActivationCodeAccessed();
#endif
            const int sizeOfLengthField = 4;
            int limit = _parentMessage.Limit;
            _buffer.CheckLimit(limit + sizeOfLengthField);
            int dataLength = (int)_buffer.Uint32GetLittleEndian(limit);
            byte[] data = new byte[dataLength];
            _parentMessage.Limit = limit + sizeOfLengthField + dataLength;
            _buffer.GetBytes(limit + sizeOfLengthField, data);

            return data;
        }

        public int SetActivationCode(byte[] src, int srcOffset, int length) =>
            SetActivationCode(new ReadOnlySpan<byte>(src, srcOffset, length));

        public int SetActivationCode(ReadOnlySpan<byte> src)
        {
#if ENABLE_ACCESS_ORDER_CHECKS
            OnActivationCodeAccessed();
#endif
            const int sizeOfLengthField = 4;
            int limit = _parentMessage.Limit;
            _parentMessage.Limit = limit + sizeOfLengthField + src.Length;
            _buffer.Uint32PutLittleEndian(limit, (uint)src.Length);
            _buffer.SetBytes(limit + sizeOfLengthField, src);

            return src.Length;
        }

        public string GetActivationCode()
        {
#if ENABLE_ACCESS_ORDER_CHECKS
            OnActivationCodeAccessed();
#endif
            const int sizeOfLengthField = 4;
            int limit = _parentMessage.Limit;
            _buffer.CheckLimit(limit + sizeOfLengthField);
            int dataLength = (int)_buffer.Uint32GetLittleEndian(limit);
            _parentMessage.Limit = limit + sizeOfLengthField + dataLength;
            return _buffer.GetStringFromBytes(ActivationCodeResolvedCharacterEncoding, limit + sizeOfLengthField, dataLength);
        }

        public void SetActivationCode(string value)
        {
#if ENABLE_ACCESS_ORDER_CHECKS
            OnActivationCodeAccessed();
#endif
            var encoding = ActivationCodeResolvedCharacterEncoding;
            const int sizeOfLengthField = 4;
            int limit = _parentMessage.Limit;
            int byteCount = _buffer.SetBytesFromString(encoding, value, limit + sizeOfLengthField);
            _parentMessage.Limit = limit + sizeOfLengthField + byteCount;
            _buffer.Uint32PutLittleEndian(limit, (uint)byteCount);
        }

        public override string ToString()
        {
            var sb = new StringBuilder(100);
            this.BuildString(sb);
            return sb.ToString();
        }

        internal void BuildString(StringBuilder builder)
        {
            if (_buffer == null)
            {
                throw new ArgumentNullException("_buffer");
            }

            int originalLimit = this.Limit;
#if ENABLE_ACCESS_ORDER_CHECKS
            CodecState originalState = _codecState;
            _codecState = CodecState.NOT_WRAPPED;
            OnWrapForDecode(_actingVersion);
#endif
            this.Limit = _offset + _actingBlockLength;
            builder.Append("[Car](sbeTemplateId=");
            builder.Append(Car.TemplateId);
            builder.Append("|sbeSchemaId=");
            builder.Append(Car.SchemaId);
            builder.Append("|sbeSchemaVersion=");
            if (_parentMessage._actingVersion != Car.SchemaVersion)
            {
                builder.Append(_parentMessage._actingVersion);
                builder.Append('/');
            }
            builder.Append(Car.SchemaVersion);
            builder.Append("|sbeBlockLength=");
            if (_actingBlockLength != Car.BlockLength)
            {
                builder.Append(_actingBlockLength);
                builder.Append('/');
            }
            builder.Append(Car.BlockLength);
            builder.Append("):");

            builder.Append("SerialNumber=");
            builder.Append(this.SerialNumber);
            builder.Append('|');
            builder.Append("ModelYear=");
            builder.Append(this.ModelYear);
            builder.Append('|');
            builder.Append("Available=");
            builder.Append(this.Available);
            builder.Append('|');
            builder.Append("Code=");
            builder.Append(this.Code);
            builder.Append('|');
            builder.Append("SomeNumbers=");
            builder.Append('[');
            for (int i = 0; i < SomeNumbersLength; ++i)
            {
                if (i > 0)
                {
                    builder.Append(',');
                }
                builder.Append(GetSomeNumbers(i));
            }
            builder.Append(']');
            builder.Append('|');
            builder.Append("VehicleCode=");
            builder.Append("'");
            for (int i = 0; i < VehicleCodeLength && this.GetVehicleCode(i) > 0; ++i)
            {
                builder.Append((char)this.GetVehicleCode(i));
            }
            builder.Append("'");
            builder.Append('|');
            builder.Append("Extras=");
            this.Extras.BuildString(builder);
            builder.Append('|');
            builder.Append("DiscountedModel=");
            builder.Append(this.DiscountedModel);
            builder.Append('|');
            builder.Append("Engine=");
            if (this.Engine != null)
            {
                this.Engine.BuildString(builder);
            }
            else
            {
                builder.Append("null");
            }
            builder.Append('|');
            builder.Append("FuelFigures=[");
            var fuelFigures = this.FuelFigures;
            if (fuelFigures.Count > 0)
            {
                var first = true;
                while (fuelFigures.HasNext)
                {
                    if (!first)
                    {
                        builder.Append(',');
                    }
                    first = false;
                    fuelFigures.Next().BuildString(builder);
                }
            }
            builder.Append("]");
            builder.Append('|');
            builder.Append("PerformanceFigures=[");
            var performanceFigures = this.PerformanceFigures;
            if (performanceFigures.Count > 0)
            {
                var first = true;
                while (performanceFigures.HasNext)
                {
                    if (!first)
                    {
                        builder.Append(',');
                    }
                    first = false;
                    performanceFigures.Next().BuildString(builder);
                }
            }
            builder.Append("]");
            builder.Append('|');
            builder.Append("Manufacturer=");
            builder.Append('\'').Append(GetManufacturer()).Append('\'');
            builder.Append('|');
            builder.Append("Model=");
            builder.Append('\'').Append(GetModel()).Append('\'');
            builder.Append('|');
            builder.Append("ActivationCode=");
            builder.Append('\'').Append(GetActivationCode()).Append('\'');

#if ENABLE_ACCESS_ORDER_CHECKS
            _codecState = originalState;
#endif
            this.Limit = originalLimit;

        }
    }
}
